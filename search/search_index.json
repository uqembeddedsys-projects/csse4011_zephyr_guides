{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to CSSE4011 Hey everyone, Welcome to CSSE4011 !. The following set of documentation are meant to help you get upto speed with Zephyr RTOS. There are 3 sections: OS - OS Basics Connectivity - I/O with Zephyr Boards - Board setup guides The tutorials in each of these sections are meant to help you prepare for upcoming practicals. You should attempt/read through them to understand the basics. If you have any questions/issues, feel free to ask us on Ed or to come along to the pracs! Thulith Wilfred,","title":"Welcome to CSSE4011"},{"location":"#welcome-to-csse4011","text":"Hey everyone, Welcome to CSSE4011 !. The following set of documentation are meant to help you get upto speed with Zephyr RTOS. There are 3 sections: OS - OS Basics Connectivity - I/O with Zephyr Boards - Board setup guides The tutorials in each of these sections are meant to help you prepare for upcoming practicals. You should attempt/read through them to understand the basics. If you have any questions/issues, feel free to ask us on Ed or to come along to the pracs! Thulith Wilfred,","title":"Welcome to CSSE4011"},{"location":"about/","text":"Tutorial Documentation OS A set of tutorials focused on getting upto speed with Zephyr RTOS and it's feature set/implementation. Tute 1: Getting Started [OK] Tute 2: First program [OK] 2.1: Building Tips [OK] 2.2: Implementing Libraries [OK] Tute 3: Debugger Tute 4: Threading [OK] Tute 5: Thread Synchronisation 5.1: Thread Sync [OK] 5.2: Thread Communications (ITC) [OK] Tute 6: File Systems [TODO] Connectivity A set of tutorials that expose connectivity / I/O features of Zephyr RTOS Tute 1: GPIO [OK] Tute 2: Sensors [OK] Tute 3: Serial Console [OK] Tute 4: Shell [OK] Tute 4.1: Shell Commands [OK] Tute 5: Logging [OK] Tute 6: Segger RTT [OK] Networking The following set of tutorials will focus on introducing networking within Zephyr RTOS. Tute 1: BLE [TODO] Tute 2: Lorawan [TODO] Tute 3: Web Dashboard [TODO] Boards A step-by-step guide to building Zephyr applications for the following boards, that are to be used within the course. Tute 1: Arduino Sense [OK] Tute 2: Thingy52 [TODO] Tute 3: IOT Board [TODO] Notes The following tutorials were created with reference to Zephyr RTOS V2.7.XX .","title":"Contents"},{"location":"about/#tutorial-documentation","text":"","title":"Tutorial Documentation"},{"location":"about/#os","text":"A set of tutorials focused on getting upto speed with Zephyr RTOS and it's feature set/implementation. Tute 1: Getting Started [OK] Tute 2: First program [OK] 2.1: Building Tips [OK] 2.2: Implementing Libraries [OK] Tute 3: Debugger Tute 4: Threading [OK] Tute 5: Thread Synchronisation 5.1: Thread Sync [OK] 5.2: Thread Communications (ITC) [OK] Tute 6: File Systems [TODO]","title":"OS"},{"location":"about/#connectivity","text":"A set of tutorials that expose connectivity / I/O features of Zephyr RTOS Tute 1: GPIO [OK] Tute 2: Sensors [OK] Tute 3: Serial Console [OK] Tute 4: Shell [OK] Tute 4.1: Shell Commands [OK] Tute 5: Logging [OK] Tute 6: Segger RTT [OK]","title":"Connectivity"},{"location":"about/#networking","text":"The following set of tutorials will focus on introducing networking within Zephyr RTOS. Tute 1: BLE [TODO] Tute 2: Lorawan [TODO] Tute 3: Web Dashboard [TODO]","title":"Networking"},{"location":"about/#boards","text":"A step-by-step guide to building Zephyr applications for the following boards, that are to be used within the course. Tute 1: Arduino Sense [OK] Tute 2: Thingy52 [TODO] Tute 3: IOT Board [TODO]","title":"Boards"},{"location":"about/#notes","text":"The following tutorials were created with reference to Zephyr RTOS V2.7.XX .","title":"Notes"},{"location":"Boards/BRD.1-Arduino_Sense/","text":"CSSE4011: Arduino-Sense: Zephyr Board Guide 1.0 Prerequisites Complete following OS tutes Getting Started First Program 2.0 Arduino Sense - Zephyr This Arduino board requires an extra step compared to building and flashing a most other boards. This particular board requires \"the Arduino variant of bossac\". Where, BOSSA - \"Basic Open Source Sam-ba Application\" and \"SAM-BA\" is the \"SAM Boot Assistant\". BOSSAC is a command-line implementation of BOSSA. 2.1 Getting the BOSSAC The bossac can be setup in a few different ways, the easiest is to clone the appropriate repository and compile the program. In the csse4011-vm, after completing the getting started guide, perform the following. Step 1: Install Dependencies sudo apt-get install libreadline-dev libwxgtk3.0-gtk3-dev Step 2: Clone BOSSA cd csse4011/ git clone https://github.com/arduino/BOSSA.git Step 3: Make Bossa cd BOSSA/ make Step 4: Verify that bin/ has been successfully created with a binary named 'bossac'. 2.2 TTY Permissions for Flashing To allow for west to load binary into bootloader, tty permissions must be given to the user. An easy way to do this is to add the current user to the 'dialout' group. sudo usermod -a -G dialout $USER You will typically need to log out and log in or reboot to see this effect . 2.3 Building and Flashing Ensure that the USB is connected to the Arduino Sense board, and that it is passed through by the host machine into the virtual machine. An application for this board can be built with, (from within Zephyr Application directory - see OS.1) west build -p auto -b arduino_nano_33_ble and flashed with west flash --bossac = $HOME /csse4011/BOSSA/BOSSA/bin/bossac where $HOME is typically, /home/user , so ensure that the path to 'bossac' is correct.","title":"1.0 Arduino Sense BLE"},{"location":"Boards/BRD.1-Arduino_Sense/#csse4011-arduino-sense-zephyr-board-guide","text":"","title":"CSSE4011: Arduino-Sense: Zephyr Board Guide"},{"location":"Boards/BRD.1-Arduino_Sense/#10-prerequisites","text":"Complete following OS tutes Getting Started First Program","title":"1.0 Prerequisites"},{"location":"Boards/BRD.1-Arduino_Sense/#20-arduino-sense-zephyr","text":"This Arduino board requires an extra step compared to building and flashing a most other boards. This particular board requires \"the Arduino variant of bossac\". Where, BOSSA - \"Basic Open Source Sam-ba Application\" and \"SAM-BA\" is the \"SAM Boot Assistant\". BOSSAC is a command-line implementation of BOSSA.","title":"2.0 Arduino Sense - Zephyr"},{"location":"Boards/BRD.1-Arduino_Sense/#21-getting-the-bossac","text":"The bossac can be setup in a few different ways, the easiest is to clone the appropriate repository and compile the program. In the csse4011-vm, after completing the getting started guide, perform the following. Step 1: Install Dependencies sudo apt-get install libreadline-dev libwxgtk3.0-gtk3-dev Step 2: Clone BOSSA cd csse4011/ git clone https://github.com/arduino/BOSSA.git Step 3: Make Bossa cd BOSSA/ make Step 4: Verify that bin/ has been successfully created with a binary named 'bossac'.","title":"2.1 Getting the BOSSAC"},{"location":"Boards/BRD.1-Arduino_Sense/#22-tty-permissions-for-flashing","text":"To allow for west to load binary into bootloader, tty permissions must be given to the user. An easy way to do this is to add the current user to the 'dialout' group. sudo usermod -a -G dialout $USER You will typically need to log out and log in or reboot to see this effect .","title":"2.2 TTY Permissions for Flashing"},{"location":"Boards/BRD.1-Arduino_Sense/#23-building-and-flashing","text":"Ensure that the USB is connected to the Arduino Sense board, and that it is passed through by the host machine into the virtual machine. An application for this board can be built with, (from within Zephyr Application directory - see OS.1) west build -p auto -b arduino_nano_33_ble and flashed with west flash --bossac = $HOME /csse4011/BOSSA/BOSSA/bin/bossac where $HOME is typically, /home/user , so ensure that the path to 'bossac' is correct.","title":"2.3 Building and Flashing"},{"location":"Boards/BRD.2-Thingy52/","text":"CSSE4011: Thingy52: Zephyr Board Guide 1.0 Prerequisites Complete following OS tutes Getting Started First Program 1.1 Test Hardware Thingy52 2x mUSB Cable Segger J-Link EDU mini 2.0 Installing SEGGER Tools NOTE: For flashing to work, you must first install J-Link Software and Documentation pack in your VM , use the 64-bit DEB installer for Debian . To install this, open up a terminal and navigate to download location. cd ~/Downloads #Make sure the file name is right, versions change often sudo dpkg -i JLink_Linux_V762_x86_64.deb Make sure that the JLink device is connected up properly to the Thingy52 device, and ensure that the power switch is to the left (facing you - on position). It is a good idea to have the device connected via mUSB for charging during this procedure. Once this has been completed, you can test that it is functional with $ JLinkExe SEGGER J-Link Commander V7.62 ( Compiled Feb 16 2022 16 :09:54 ) DLL version V7.62, compiled Feb 16 2022 16 :09:39 Connecting to J-Link via USB...O.K. Firmware: J-Link EDU Mini V1 compiled Dec 7 2021 08 :38:51 Hardware version: V1.00 S/N: 801026632 License ( s ) : FlashBP, GDB USB speed mode: Full speed ( 12 MBit/s ) VTref = 3 .286V at this point if you get Connecting to J-Link via USB...FAILED: Cannot connect to J-Link. This means that either your connections are wrong or more likely that the VM has not been passed the USB from host. You can test this by running. lsusb Bus 001 Device 003 : ID 1366 :0101 SEGGER J-Link PLUS If you do not see this device, check if the host can see this device, if so, you will need to configure the VM to allow passthrough for the SEGGER EDU Mini. 3.0 Thingy52 - Zephyr The thingy52 has a simple build and flash procedure. To build for the thingy52 simply: #Within the application directory west build -p auto -b thingy52_nrf52832 the thingy52 can now be flashed with #Within the application directory west flash -r jlink","title":"2.0 Thingy52"},{"location":"Boards/BRD.2-Thingy52/#csse4011-thingy52-zephyr-board-guide","text":"","title":"CSSE4011: Thingy52: Zephyr Board Guide"},{"location":"Boards/BRD.2-Thingy52/#10-prerequisites","text":"Complete following OS tutes Getting Started First Program","title":"1.0 Prerequisites"},{"location":"Boards/BRD.2-Thingy52/#11-test-hardware","text":"Thingy52 2x mUSB Cable Segger J-Link EDU mini","title":"1.1 Test Hardware"},{"location":"Boards/BRD.2-Thingy52/#20-installing-segger-tools","text":"NOTE: For flashing to work, you must first install J-Link Software and Documentation pack in your VM , use the 64-bit DEB installer for Debian . To install this, open up a terminal and navigate to download location. cd ~/Downloads #Make sure the file name is right, versions change often sudo dpkg -i JLink_Linux_V762_x86_64.deb Make sure that the JLink device is connected up properly to the Thingy52 device, and ensure that the power switch is to the left (facing you - on position). It is a good idea to have the device connected via mUSB for charging during this procedure. Once this has been completed, you can test that it is functional with $ JLinkExe SEGGER J-Link Commander V7.62 ( Compiled Feb 16 2022 16 :09:54 ) DLL version V7.62, compiled Feb 16 2022 16 :09:39 Connecting to J-Link via USB...O.K. Firmware: J-Link EDU Mini V1 compiled Dec 7 2021 08 :38:51 Hardware version: V1.00 S/N: 801026632 License ( s ) : FlashBP, GDB USB speed mode: Full speed ( 12 MBit/s ) VTref = 3 .286V at this point if you get Connecting to J-Link via USB...FAILED: Cannot connect to J-Link. This means that either your connections are wrong or more likely that the VM has not been passed the USB from host. You can test this by running. lsusb Bus 001 Device 003 : ID 1366 :0101 SEGGER J-Link PLUS If you do not see this device, check if the host can see this device, if so, you will need to configure the VM to allow passthrough for the SEGGER EDU Mini.","title":"2.0 Installing SEGGER Tools"},{"location":"Boards/BRD.2-Thingy52/#30-thingy52-zephyr","text":"The thingy52 has a simple build and flash procedure. To build for the thingy52 simply: #Within the application directory west build -p auto -b thingy52_nrf52832 the thingy52 can now be flashed with #Within the application directory west flash -r jlink","title":"3.0 Thingy52 - Zephyr"},{"location":"Boards/BRD.3-Dongle_NRF52840/","text":"CSSE4011: nRF Dongle: Zephyr Board Guide 1.0 Prerequisites Complete following OS tutes Getting Started First Program 1.1 Test Hardware nRF Dongle 2.0 Tools For flashing this board, we need to install nrfutil . pip3 install nrfutil nrfutil Usage: nrfutil [ OPTIONS ] COMMAND [ ARGS ] ... Options: -v, --verbose Increase verbosity of output. Can be specified more than once ( up to -v -v -v -v ) . -o, --output <filename> Log output to file --help Show this message and exit. 2.1 TTY Permissions for Flashing TTY permissions are required to load the binary by nrfutil . An easy way to do this is to add the current user to the 'dialout' group. sudo usermod -a -G dialout $USER You will typically need to log out and log in or reboot to see this effect . 3.0 nRF Dongle (nRF52840) - Zephyr To build an application, from within the application directory west build -p auto -b nrf52840dongle_nrf52840 Package the application for the bootloader using nrfutil : nrfutil pkg generate --hw-version 52 --sd-req = 0x00 \\ --application build/zephyr/zephyr.hex \\ --application-version 1 blinky.zip Now, put the device into bootloader mode, by pressing the sideways push button (next to the white pushbutton). You should see the red led steadily blinky. nrfutil dfu usb-serial -pkg blinky.zip -p /dev/ttyACM0 4.0 Troubleshooting If you get a permissions error when flashing, it is likely because you did not log out/in after updating groups. If it fails to flash, it could be because the VM does not see the DFU Bootloader . Run: lsusb and see if the following comes up Bus 001 Device 009 : ID 1915 :521f Nordic Semiconductor ASA Open DFU Bootloader If not, you will need to edit VM settings and passthrough this USB from the host to the VM.","title":"3.0 nRF Dongle"},{"location":"Boards/BRD.3-Dongle_NRF52840/#csse4011-nrf-dongle-zephyr-board-guide","text":"","title":"CSSE4011: nRF Dongle: Zephyr Board Guide"},{"location":"Boards/BRD.3-Dongle_NRF52840/#10-prerequisites","text":"Complete following OS tutes Getting Started First Program","title":"1.0 Prerequisites"},{"location":"Boards/BRD.3-Dongle_NRF52840/#11-test-hardware","text":"nRF Dongle","title":"1.1 Test Hardware"},{"location":"Boards/BRD.3-Dongle_NRF52840/#20-tools","text":"For flashing this board, we need to install nrfutil . pip3 install nrfutil nrfutil Usage: nrfutil [ OPTIONS ] COMMAND [ ARGS ] ... Options: -v, --verbose Increase verbosity of output. Can be specified more than once ( up to -v -v -v -v ) . -o, --output <filename> Log output to file --help Show this message and exit.","title":"2.0 Tools"},{"location":"Boards/BRD.3-Dongle_NRF52840/#21-tty-permissions-for-flashing","text":"TTY permissions are required to load the binary by nrfutil . An easy way to do this is to add the current user to the 'dialout' group. sudo usermod -a -G dialout $USER You will typically need to log out and log in or reboot to see this effect .","title":"2.1 TTY Permissions for Flashing"},{"location":"Boards/BRD.3-Dongle_NRF52840/#30-nrf-dongle-nrf52840-zephyr","text":"To build an application, from within the application directory west build -p auto -b nrf52840dongle_nrf52840 Package the application for the bootloader using nrfutil : nrfutil pkg generate --hw-version 52 --sd-req = 0x00 \\ --application build/zephyr/zephyr.hex \\ --application-version 1 blinky.zip Now, put the device into bootloader mode, by pressing the sideways push button (next to the white pushbutton). You should see the red led steadily blinky. nrfutil dfu usb-serial -pkg blinky.zip -p /dev/ttyACM0","title":"3.0 nRF Dongle (nRF52840) - Zephyr"},{"location":"Boards/BRD.3-Dongle_NRF52840/#40-troubleshooting","text":"If you get a permissions error when flashing, it is likely because you did not log out/in after updating groups. If it fails to flash, it could be because the VM does not see the DFU Bootloader . Run: lsusb and see if the following comes up Bus 001 Device 009 : ID 1915 :521f Nordic Semiconductor ASA Open DFU Bootloader If not, you will need to edit VM settings and passthrough this USB from the host to the VM.","title":"4.0 Troubleshooting"},{"location":"Boards/about/","text":"Board Build Guide Overview The following set of tutorials will focus on providing step-by-step instructions for building and flashing a basic Zephyr Aplication on to the following boards 1. Thingy52 2. Arduino Sense (BLE) 3. Dongle NRF52840 The instructions are based on those provided by Zephyr - Board Flashing Guide [1] Links [1] https://docs.zephyrproject.org/latest/boards/index.html","title":"Overview"},{"location":"Boards/about/#board-build-guide","text":"","title":"Board Build Guide"},{"location":"Boards/about/#overview","text":"The following set of tutorials will focus on providing step-by-step instructions for building and flashing a basic Zephyr Aplication on to the following boards 1. Thingy52 2. Arduino Sense (BLE) 3. Dongle NRF52840 The instructions are based on those provided by Zephyr - Board Flashing Guide [1]","title":"Overview"},{"location":"Boards/about/#links","text":"[1] https://docs.zephyrproject.org/latest/boards/index.html","title":"Links"},{"location":"Connectivity/CN.1-GPIO/","text":"CSSE4011: Connectivity - GPIO 1.0 Motivation The following tutorial explores exposing the board GPIO (General Purpose Input/Output) to userspace (an app) within Zephyr. Zephyr does things a little differently when it comes to interacting with hardware. In this tutorial, we will use the GPIO API to interact with GPIO pins. 1.1 Test Hardware Arduino Sense Board mUSB Cable This implementation is valid for Zephyr RTOS Version 2.7.XX 1.2. Prerequisites Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1 and BRD.1 1.3 Setup Connect the Arduino sense board to the host machine and ensure that the development environment has access to the device (USB passthrough to virtual machine). 2.0 Zephyr GPIO Implementation 2.1 Boilerplate The following commands assume that you have setup your files/directories following the respective tutorial(s). Create a new application directory for a sample gpio application. cd ~/csse4011/csse4011_repo/ mkdir -p apps/gpio_sample/ For setting up a basic boilerplate for our application, we will use the provided blinky sample in Zephyr. cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky cp -R * ~/csse4011/csse4011_repo/apps/gpio_sample/ cd ~/csse4011/csse4011_repo/apps/gpio_sample/ Alternatively, you may create your own application if desired. 2.2 DeviceTree Summary \"A devicetree is a hierarchical data structure that describes hardware...Zephyr uses devicetree to describe the hardware available on its Supported Boards, as well as that hardware\u2019s initial configuration.\" An extensive guide to DeviceTree Source (DTS) implementation can be found here & here . Later in this course, you might need to describe hardware in a DTS overlay file and add it to the build system for Zephyr to access particular hardware that you may need to use. Adding DTS overlays has been covered in OS.2.1-Building_Tips . When an application is built for a particular board, Zephyr creates a final zephyr.dts file in the build directory. This file concatenates all selected hardware into this \"final devicetree\". Typically, it's a good idea to start here to see what the hardware description looks like for the current configuration of your build. For instance, lets try building this boilerplate blinky app for the Arduino_Nano_Sense . cd ~/csse4011/csse4011_repo/apps/gpio_sample/ west build -p auto -b arduino_nano_33_ble Once the build is complete, you can open up the \"final DTS\" at: cd build/zephyr vim zephyr.dts Here we can see the hardware description for the Arduino_Nano_Sense . This information is exposed to userland/application in Zephyr, using a set of macros see here . In this tutorial, we are interested in GPIO, so we will look at how to toggle a particular GPIO pin from looking at the zephyr.dts file. 2.2 GPIO Interaction Typically, when you interact with new hardware, you must first enable the kernel driver for it, this is usually done using a kernel configuration file (KConfig). In our case for GPIO, it is enabled in the prj.conf file in the application directory with CONFIG_GPIO=y . Most boards will typically have basic hardware functionality like gpio, uart and i2c enabled by default in the board definitions (in the Zephyr source). You can refer to OS.2.1-Building_Tips for a guide on adding segmented KConf files to the build system. If you have already read through the blinky sample that we use as boilerplate, you may have already noticed that to toggle the led, it uses the device-tree macros from within the main.c file. For example, /* The devicetree node identifier for the \"led0\" alias. */ #define LED0_NODE DT_ALIAS(led0) #if DT_NODE_HAS_STATUS(LED0_NODE, okay) #define LED0 DT_GPIO_LABEL(LED0_NODE, gpios) #define PIN DT_GPIO_PIN(LED0_NODE, gpios) #define FLAGS DT_GPIO_FLAGS(LED0_NODE, gpios) Here, DT_ALIAS() is used to find the reference led0 within the DTS. This is a special case of using an alias. If we look in the zephyr.dts file, you will notice that led0 is specified as aliases{} . So this macro \"returns a node identifier for the node which is aliased\". When you follow the led0 alias in zephyr.dts , you will notice that it simply maps to a GPIO pin. Aliases can help abstract the hardware within the devicetree and make them easy to access. 2.4 DeviceTree GPIO Access Lets investigate toggling a particular GPIO that is not aliased. We will use the Arduino_Nano_Sense for this tute. You can find the board pinout here . We will use the GPIO pin P0.13 (internally connected to the top left led) for this. This pin maps on P0 , in the zephyr.dts this is gpio0 . For instance, pin D6 , will be in gpio1 . Start by editing the source file and append the following vim src/main.c Use DT_NODELABEL to get the respective node_id for for gpio0 from DTS. /* DeviceTree get node ID from label */ #define GPIO0 DT_NODELABEL(gpio0) #define GPIO0_13 0x0D //PIN PO.13 In our main function, let's init the GPIO PIN. const struct device * dev_gpio0 ; dev_gpio0 = device_get_binding ( DT_LABEL ( GPIO0 )); /* Configure PIN_A0 as an Output with that is Active Low */ ret = gpio_pin_configure ( dev_gpio0 , GPIO0_13 , GPIO_OUTPUT_ACTIVE | GPIO_ACTIVE_LOW ); Notice here, that device_get_binding() will not except a NODE_ID , but it does accept a NODE_LABEL , hence why DT_LABEL is used. DT_LABEL is a helper macro that does the same as DT_PROP(GPIO0, label) . The struct device see here returned by this function call describes the particular hardware and is used by the API to interface to that particular device/hardware. and finally in our while loop, we can toggle this pin. while ( 1 ) { gpio_pin_set ( dev , PIN , ( int ) led_is_on ); /* Toggle the PIN */ gpio_pin_set ( dev_gpio0 , GPIO0_13 , ( int ) led_is_on ); led_is_on = ! led_is_on ; k_msleep ( SLEEP_TIME_MS ); } 4.0 Testing This application can now be built and flashed using: west build -p auto -b arduino_nano_33_ble west flash --bossac = $HOME /csse4011/BOSSA/BOSSA/bin/bossac #Check the Path is correct You should see that the top-led led is now flashing orange alongside the red led (led0) from the boilerplate code. 4.1 Sample Application A sample application has been provided, this application includes all the steps mentioned above. Sample is located in: REPO_TOP/tute_solutions/gpio_sample/","title":"1.0 GPIO"},{"location":"Connectivity/CN.1-GPIO/#csse4011-connectivity-gpio","text":"","title":"CSSE4011: Connectivity - GPIO"},{"location":"Connectivity/CN.1-GPIO/#10-motivation","text":"The following tutorial explores exposing the board GPIO (General Purpose Input/Output) to userspace (an app) within Zephyr. Zephyr does things a little differently when it comes to interacting with hardware. In this tutorial, we will use the GPIO API to interact with GPIO pins.","title":"1.0 Motivation"},{"location":"Connectivity/CN.1-GPIO/#11-test-hardware","text":"Arduino Sense Board mUSB Cable This implementation is valid for Zephyr RTOS Version 2.7.XX","title":"1.1 Test Hardware"},{"location":"Connectivity/CN.1-GPIO/#12-prerequisites","text":"Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1 and BRD.1","title":"1.2. Prerequisites"},{"location":"Connectivity/CN.1-GPIO/#13-setup","text":"Connect the Arduino sense board to the host machine and ensure that the development environment has access to the device (USB passthrough to virtual machine).","title":"1.3 Setup"},{"location":"Connectivity/CN.1-GPIO/#20-zephyr-gpio-implementation","text":"","title":"2.0 Zephyr GPIO Implementation"},{"location":"Connectivity/CN.1-GPIO/#21-boilerplate","text":"The following commands assume that you have setup your files/directories following the respective tutorial(s). Create a new application directory for a sample gpio application. cd ~/csse4011/csse4011_repo/ mkdir -p apps/gpio_sample/ For setting up a basic boilerplate for our application, we will use the provided blinky sample in Zephyr. cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky cp -R * ~/csse4011/csse4011_repo/apps/gpio_sample/ cd ~/csse4011/csse4011_repo/apps/gpio_sample/ Alternatively, you may create your own application if desired.","title":"2.1 Boilerplate"},{"location":"Connectivity/CN.1-GPIO/#22-devicetree-summary","text":"\"A devicetree is a hierarchical data structure that describes hardware...Zephyr uses devicetree to describe the hardware available on its Supported Boards, as well as that hardware\u2019s initial configuration.\" An extensive guide to DeviceTree Source (DTS) implementation can be found here & here . Later in this course, you might need to describe hardware in a DTS overlay file and add it to the build system for Zephyr to access particular hardware that you may need to use. Adding DTS overlays has been covered in OS.2.1-Building_Tips . When an application is built for a particular board, Zephyr creates a final zephyr.dts file in the build directory. This file concatenates all selected hardware into this \"final devicetree\". Typically, it's a good idea to start here to see what the hardware description looks like for the current configuration of your build. For instance, lets try building this boilerplate blinky app for the Arduino_Nano_Sense . cd ~/csse4011/csse4011_repo/apps/gpio_sample/ west build -p auto -b arduino_nano_33_ble Once the build is complete, you can open up the \"final DTS\" at: cd build/zephyr vim zephyr.dts Here we can see the hardware description for the Arduino_Nano_Sense . This information is exposed to userland/application in Zephyr, using a set of macros see here . In this tutorial, we are interested in GPIO, so we will look at how to toggle a particular GPIO pin from looking at the zephyr.dts file.","title":"2.2 DeviceTree Summary"},{"location":"Connectivity/CN.1-GPIO/#22-gpio-interaction","text":"Typically, when you interact with new hardware, you must first enable the kernel driver for it, this is usually done using a kernel configuration file (KConfig). In our case for GPIO, it is enabled in the prj.conf file in the application directory with CONFIG_GPIO=y . Most boards will typically have basic hardware functionality like gpio, uart and i2c enabled by default in the board definitions (in the Zephyr source). You can refer to OS.2.1-Building_Tips for a guide on adding segmented KConf files to the build system. If you have already read through the blinky sample that we use as boilerplate, you may have already noticed that to toggle the led, it uses the device-tree macros from within the main.c file. For example, /* The devicetree node identifier for the \"led0\" alias. */ #define LED0_NODE DT_ALIAS(led0) #if DT_NODE_HAS_STATUS(LED0_NODE, okay) #define LED0 DT_GPIO_LABEL(LED0_NODE, gpios) #define PIN DT_GPIO_PIN(LED0_NODE, gpios) #define FLAGS DT_GPIO_FLAGS(LED0_NODE, gpios) Here, DT_ALIAS() is used to find the reference led0 within the DTS. This is a special case of using an alias. If we look in the zephyr.dts file, you will notice that led0 is specified as aliases{} . So this macro \"returns a node identifier for the node which is aliased\". When you follow the led0 alias in zephyr.dts , you will notice that it simply maps to a GPIO pin. Aliases can help abstract the hardware within the devicetree and make them easy to access.","title":"2.2 GPIO Interaction"},{"location":"Connectivity/CN.1-GPIO/#24-devicetree-gpio-access","text":"Lets investigate toggling a particular GPIO that is not aliased. We will use the Arduino_Nano_Sense for this tute. You can find the board pinout here . We will use the GPIO pin P0.13 (internally connected to the top left led) for this. This pin maps on P0 , in the zephyr.dts this is gpio0 . For instance, pin D6 , will be in gpio1 . Start by editing the source file and append the following vim src/main.c Use DT_NODELABEL to get the respective node_id for for gpio0 from DTS. /* DeviceTree get node ID from label */ #define GPIO0 DT_NODELABEL(gpio0) #define GPIO0_13 0x0D //PIN PO.13 In our main function, let's init the GPIO PIN. const struct device * dev_gpio0 ; dev_gpio0 = device_get_binding ( DT_LABEL ( GPIO0 )); /* Configure PIN_A0 as an Output with that is Active Low */ ret = gpio_pin_configure ( dev_gpio0 , GPIO0_13 , GPIO_OUTPUT_ACTIVE | GPIO_ACTIVE_LOW ); Notice here, that device_get_binding() will not except a NODE_ID , but it does accept a NODE_LABEL , hence why DT_LABEL is used. DT_LABEL is a helper macro that does the same as DT_PROP(GPIO0, label) . The struct device see here returned by this function call describes the particular hardware and is used by the API to interface to that particular device/hardware. and finally in our while loop, we can toggle this pin. while ( 1 ) { gpio_pin_set ( dev , PIN , ( int ) led_is_on ); /* Toggle the PIN */ gpio_pin_set ( dev_gpio0 , GPIO0_13 , ( int ) led_is_on ); led_is_on = ! led_is_on ; k_msleep ( SLEEP_TIME_MS ); }","title":"2.4 DeviceTree GPIO Access"},{"location":"Connectivity/CN.1-GPIO/#40-testing","text":"This application can now be built and flashed using: west build -p auto -b arduino_nano_33_ble west flash --bossac = $HOME /csse4011/BOSSA/BOSSA/bin/bossac #Check the Path is correct You should see that the top-led led is now flashing orange alongside the red led (led0) from the boilerplate code.","title":"4.0 Testing"},{"location":"Connectivity/CN.1-GPIO/#41-sample-application","text":"A sample application has been provided, this application includes all the steps mentioned above. Sample is located in: REPO_TOP/tute_solutions/gpio_sample/","title":"4.1 Sample Application"},{"location":"Connectivity/CN.2-Sensors/","text":"CSSE4011: Connectivity - Sensors","title":"2.0 Sensors"},{"location":"Connectivity/CN.2-Sensors/#csse4011-connectivity-sensors","text":"","title":"CSSE4011: Connectivity - Sensors"},{"location":"Connectivity/CN.3-Serial_Console/","text":"CSSE4011: Connectivity - Serial Console The following tutorial will cover the setting up a console through USB with existing Zephyr Drivers. (Note that, USB Debugging/Shell can only be used with platforms that support USB, such as the NRF52840 SoC). 1.0 Motivation Once USB console is setup, it can be used for printk() debugging, and/or to examine the internal data structures of an application where required. 1.1 Test Hardware This implementation will explore setting up the console on the Arduino Sense board. Arduino Sense Board mUSB Cable This implementation is valid for Zephyr RTOS Version 2.7.XX 1.2. Prerequisites Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1 and BRD.1 2.0 Setting up Console 2.1 Boilerplate The following commands assume that you have setup your files/directories following the respective tutorial(s). Create a new application directory for a sample console application. cd ~/csse4011/csse4011_repo/ mkdir -p apps/console_sample/ For setting up a basic boilerplate for our application, we will use the provided blinky sample in Zephyr. cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky cp -R * ~/csse4011/csse4011_repo/apps/console_sample/ cd ~/csse4011/csse4011_repo/apps/console_sample/ 2.2 Enable USB Drivers [prj.conf] To enable the existing USB drivers, a few config options need to be added to our project. A detailed guide for the USB API is found here , which you may need to refer to for additional information. Start by editing the prj.conf file. Append the following config options. These options can be found here , for different subsystems. CONFIG_GPIO=y #------------------------------ENABLE USB--------------------------------------- CONFIG_BOARD_ARDUINO_NANO_33_BLE_EN_USB_CONSOLE=y CONFIG_USB_DEVICE_STACK=y CONFIG_USB_DEVICE_PRODUCT=\"USB Console Tute\" CONFIG_SERIAL=y CONFIG_CONSOLE=y CONFIG_UART_CONSOLE=y CONFIG_UART_LINE_CTRL=y #------------------------------------------------------------------------------ Optionally, you can add the following config statements to add some flavour to the USB Stack... These commands let you set USB device ID parameters. #--------------------------------USB OPTIONS---------------------------------- CONFIG_USB_DEVICE_PRODUCT=\"Arduino Nano BLE - Zephyr\" CONFIG_USB_DEVICE_MANUFACTURER=\"Wilfred MK\" CONFIG_USB_DEVICE_VID=0xC553 CONFIG_USB_DEVICE_PID=0x4011 #----------------------------------------------------------------------------- 2.3 Setting up CDC-ACM [app.overlay] Zephyr v2.7 require an overlay file to be added to specify Communication Device Class - Abstract Control Model (CDC-ACM). The CDC ACM can be used as backends for Zephyr Subsystems, such as console and shell. There is detailed information about how an overlay is implemented and it's purpose in this sub-system which can be found here . For this particular example, start by making an app.overlay . If there exists a file named app.overlay in the app directory, it get added to the build system by default (See here , for device tree overlays). cd ~/csse4011/csse4011_repo/apps/console_sample/ #App Directory vim app.overlay #Use any text editor Copy the following overlay details into the newly created file. This is adding a devicetree overlay to the build system, see here for more. Here we specify the console should be routed to cdc_acm_uart0. / { chosen { zephyr , console = & cdc_acm_uart0 ; }; }; & zephyr_udc0 { cdc_acm_uart0 : cdc_acm_uart0 { compatible = \"zephyr,cdc-acm-uart\" ; : q label = \"CDC_ACM_0\" ; }; }; 2.4 Initializing the Driver [main.c] At this point, ensure that there are no compile errors by running west build -p -b arduino_nano_33_ble and now we tell our application to initialize the USB and print some data. vim src/main.c #include <usb/usb_device.h> #include <drivers/uart.h> //Include these libraries //Add the following to main() void main ( void ) { /* Setup DTR */ const struct device * console_dev = DEVICE_DT_GET ( DT_CHOSEN ( zephyr_console )); uint32_t dtr = 0 ; /* Enable the USB Driver */ if ( usb_enable ( NULL )) return ; /* Wait on DTR - 'Data Terminal Ready' * Will wait here until a terminal has been attached to the device * This is not necessary, however, can be useful for printing boot info etc.. */ while ( ! dtr ) { uart_line_ctrl_get ( console_dev , UART_LINE_CTRL_DTR , & dtr ); k_sleep ( K_MSEC ( 100 )); } while ( 1 ) { printk ( \"Hello World \\n \" ); k_sleep ( K_MSEC ( 500 )); } } 2.5 Testing This application can now be built and flashed using: west build -p auto -b arduino_nano_33_ble west flash --bossac = $HOME /csse4011/BOSSA/BOSSA/bin/bossac #Check the Path is correct Since this is now a 'new usb device' , you will need to pass through USB from your host machine to the VM to open the console within your CSSE4011 VM Typically, you might have to unplug and reconnect the device for the pass through to take effect. Alternatively, you should be able to view the console on the host machine also. See that the device is connected lsusb #Command to show currently attached USB devices Bus 001 Device 099 : ID c553:4011 Wilfred MK Arduino Nano BLE - Zephyr #You will see this if you added the USB OPTIONS from above First install screen (App that can monitor terminal) sudo apt-get install screen sudo screen /dev/ttyACM0 Hello World Hello World Hello World 2.6 Sample Application A sample application has been provided, this application includes all the steps mentioned above. You can test the console by flashing it to the Arduino Sense Board. Sample is located in: REPO_TOP/tute_solutions/console_example/","title":"3.0 Serial Console"},{"location":"Connectivity/CN.3-Serial_Console/#csse4011-connectivity-serial-console","text":"The following tutorial will cover the setting up a console through USB with existing Zephyr Drivers. (Note that, USB Debugging/Shell can only be used with platforms that support USB, such as the NRF52840 SoC).","title":"CSSE4011: Connectivity - Serial Console"},{"location":"Connectivity/CN.3-Serial_Console/#10-motivation","text":"Once USB console is setup, it can be used for printk() debugging, and/or to examine the internal data structures of an application where required.","title":"1.0 Motivation"},{"location":"Connectivity/CN.3-Serial_Console/#11-test-hardware","text":"This implementation will explore setting up the console on the Arduino Sense board. Arduino Sense Board mUSB Cable This implementation is valid for Zephyr RTOS Version 2.7.XX","title":"1.1 Test Hardware"},{"location":"Connectivity/CN.3-Serial_Console/#12-prerequisites","text":"Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1 and BRD.1","title":"1.2. Prerequisites"},{"location":"Connectivity/CN.3-Serial_Console/#20-setting-up-console","text":"","title":"2.0 Setting up Console"},{"location":"Connectivity/CN.3-Serial_Console/#21-boilerplate","text":"The following commands assume that you have setup your files/directories following the respective tutorial(s). Create a new application directory for a sample console application. cd ~/csse4011/csse4011_repo/ mkdir -p apps/console_sample/ For setting up a basic boilerplate for our application, we will use the provided blinky sample in Zephyr. cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky cp -R * ~/csse4011/csse4011_repo/apps/console_sample/ cd ~/csse4011/csse4011_repo/apps/console_sample/","title":"2.1 Boilerplate"},{"location":"Connectivity/CN.3-Serial_Console/#22-enable-usb-drivers-prjconf","text":"To enable the existing USB drivers, a few config options need to be added to our project. A detailed guide for the USB API is found here , which you may need to refer to for additional information. Start by editing the prj.conf file. Append the following config options. These options can be found here , for different subsystems. CONFIG_GPIO=y #------------------------------ENABLE USB--------------------------------------- CONFIG_BOARD_ARDUINO_NANO_33_BLE_EN_USB_CONSOLE=y CONFIG_USB_DEVICE_STACK=y CONFIG_USB_DEVICE_PRODUCT=\"USB Console Tute\" CONFIG_SERIAL=y CONFIG_CONSOLE=y CONFIG_UART_CONSOLE=y CONFIG_UART_LINE_CTRL=y #------------------------------------------------------------------------------ Optionally, you can add the following config statements to add some flavour to the USB Stack... These commands let you set USB device ID parameters. #--------------------------------USB OPTIONS---------------------------------- CONFIG_USB_DEVICE_PRODUCT=\"Arduino Nano BLE - Zephyr\" CONFIG_USB_DEVICE_MANUFACTURER=\"Wilfred MK\" CONFIG_USB_DEVICE_VID=0xC553 CONFIG_USB_DEVICE_PID=0x4011 #-----------------------------------------------------------------------------","title":"2.2 Enable USB Drivers [prj.conf]"},{"location":"Connectivity/CN.3-Serial_Console/#23-setting-up-cdc-acm-appoverlay","text":"Zephyr v2.7 require an overlay file to be added to specify Communication Device Class - Abstract Control Model (CDC-ACM). The CDC ACM can be used as backends for Zephyr Subsystems, such as console and shell. There is detailed information about how an overlay is implemented and it's purpose in this sub-system which can be found here . For this particular example, start by making an app.overlay . If there exists a file named app.overlay in the app directory, it get added to the build system by default (See here , for device tree overlays). cd ~/csse4011/csse4011_repo/apps/console_sample/ #App Directory vim app.overlay #Use any text editor Copy the following overlay details into the newly created file. This is adding a devicetree overlay to the build system, see here for more. Here we specify the console should be routed to cdc_acm_uart0. / { chosen { zephyr , console = & cdc_acm_uart0 ; }; }; & zephyr_udc0 { cdc_acm_uart0 : cdc_acm_uart0 { compatible = \"zephyr,cdc-acm-uart\" ; : q label = \"CDC_ACM_0\" ; }; };","title":"2.3 Setting up CDC-ACM [app.overlay]"},{"location":"Connectivity/CN.3-Serial_Console/#24-initializing-the-driver-mainc","text":"At this point, ensure that there are no compile errors by running west build -p -b arduino_nano_33_ble and now we tell our application to initialize the USB and print some data. vim src/main.c #include <usb/usb_device.h> #include <drivers/uart.h> //Include these libraries //Add the following to main() void main ( void ) { /* Setup DTR */ const struct device * console_dev = DEVICE_DT_GET ( DT_CHOSEN ( zephyr_console )); uint32_t dtr = 0 ; /* Enable the USB Driver */ if ( usb_enable ( NULL )) return ; /* Wait on DTR - 'Data Terminal Ready' * Will wait here until a terminal has been attached to the device * This is not necessary, however, can be useful for printing boot info etc.. */ while ( ! dtr ) { uart_line_ctrl_get ( console_dev , UART_LINE_CTRL_DTR , & dtr ); k_sleep ( K_MSEC ( 100 )); } while ( 1 ) { printk ( \"Hello World \\n \" ); k_sleep ( K_MSEC ( 500 )); } }","title":"2.4 Initializing the Driver [main.c]"},{"location":"Connectivity/CN.3-Serial_Console/#25-testing","text":"This application can now be built and flashed using: west build -p auto -b arduino_nano_33_ble west flash --bossac = $HOME /csse4011/BOSSA/BOSSA/bin/bossac #Check the Path is correct Since this is now a 'new usb device' , you will need to pass through USB from your host machine to the VM to open the console within your CSSE4011 VM Typically, you might have to unplug and reconnect the device for the pass through to take effect. Alternatively, you should be able to view the console on the host machine also. See that the device is connected lsusb #Command to show currently attached USB devices Bus 001 Device 099 : ID c553:4011 Wilfred MK Arduino Nano BLE - Zephyr #You will see this if you added the USB OPTIONS from above First install screen (App that can monitor terminal) sudo apt-get install screen sudo screen /dev/ttyACM0 Hello World Hello World Hello World","title":"2.5 Testing"},{"location":"Connectivity/CN.3-Serial_Console/#26-sample-application","text":"A sample application has been provided, this application includes all the steps mentioned above. You can test the console by flashing it to the Arduino Sense Board. Sample is located in: REPO_TOP/tute_solutions/console_example/","title":"2.6 Sample Application"},{"location":"Connectivity/CN.4-Shell/","text":"CSSE4011: Connectivity - Shell The following tutorial will cover the setting up a command line interface/Shell through USB with existing Zephyr Drivers. (Note that, USB Debugging/Shell can only be used with platforms that support USB, such as the NRF52840 SoC). 1.0 Motivation A shell or a command line interface (CLI) allows for a user to interact with the OS in real time. Shell commands can be used to issue unique commands to a device or change application logic. For example, a command to read run-time statistics of threads or to turn an led on or off etc... Zephyr also allows for Shell to be used as a backend for the Zephyr Logging API. The logging API is explored in CN.5-Logging . 1.1 Test Hardware Arduino Sense Board mUSB Cable This implementation is valid for Zephyr RTOS Version 2.7.XX 1.2. Prerequisites Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1 and BRD.1 1.3 Setup Connect the Arduino sense board to the host machine and ensure that the development environment has access to the device (USB passthrough to virtual machine). 2.0 Zephyr Shell Implementation 2.1 Boilerplate The following commands assume that you have setup your files/directories following the respective tutorial(s). Create a new application directory for a sample shell application. cd ~/csse4011/csse4011_repo/ mkdir -p apps/shell_sample/ For setting up a basic boilerplate for our application, we will use the provided blinky sample in Zephyr. cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky cp -R * ~/csse4011/csse4011_repo/apps/shell_sample/ cd ~/csse4011/csse4011_repo/apps/shell_sample/ 2.2 Enable USB Drivers [prj.conf] To show a more structure approach to setting configs in Zephyr, in this tutorials we will explore the addition of segmented config files to the build system. Where each file represents a different subsystem. Such an approach improves modularity for bigger projects. First, we will enable the USB subsystem as before, These options can be found here , for diffrent subsystems. vim usb.conf #create a new .conf file for the USB subsystem Append the following, then save and exit the editor. #----------------------------------USB SETUP---------------------------------- CONFIG_USB_DEVICE_STACK=y CONFIG_USB_DEVICE_PRODUCT=\"Zephyr USB shell sample\" #----------------------------------------------------------------------------- #--------------------------------USB_OPTIONS---------------------------------- CONFIG_USB_DEVICE_PRODUCT=\"Arduino Nano BLE - Zephyr\" CONFIG_USB_DEVICE_MANUFACTURER=\"Wilfred MK\" CONFIG_USB_DEVICE_VID=0xC553 CONFIG_USB_DEVICE_PID=0x4011 #----------------------------------------------------------------------------- Next, we will enable Zephyr Shell, vim shell.conf #create a new .conf file for shell options append the following config settings. #-----------------------------SHELL_CONF-------------------------------------- CONFIG_SHELL_BACKEND_SERIAL_CHECK_DTR=y CONFIG_UART_LINE_CTRL=y CONFIG_SHELL_BACKEND_SERIAL_INIT_PRIORITY=51 CONFIG_SHELL=y CONFIG_SHELL_BACKENDS=y CONFIG_SHELL_BACKEND_SERIAL=y CONFIG_SHELL_PROMPT_UART=\"CSSE4011:~$\" CONFIG_SHELL_CMDS=y CONFIG_SHELL_TAB=y CONFIG_SHELL_TAB_AUTOCOMPLETION=y CONFIG_SHELL_VT100_COLORS=y CONFIG_KERNEL_SHELL=y #----------------------------------------------------------------------------- #-----------------------------SHELL_LOGGING----------------------------------- CONFIG_LOG=y CONFIG_LOG_PRINTK=y #----------------------------------------------------------------------------- Save the file and exit the editor. 2.3 Shell USB Overlay As with the console, we must inform Zephyr that the shell-uart is to be routed through the USB subsystem using CDC_ACM . This can be done by creating and adding an overlay file to the build-system. An ' app.overlay' file can be created similarly to the console tutorial, and this will automatically be picked up by the build-system . However, here we will explore manually adding it to the build system. vim dtc_shell.overlay #create new file for shell overlay append the following to the file. / { chosen { zephyr , shell-uart = & cdc_acm_uart0 ; }; }; & zephyr_udc0 { cdc_acm_uart0 : cdc_acm_uart0 { compatible = \"zephyr,cdc-acm-uart\" ; label = \"CDC_ACM_0\" ; }; }; Save and exit the editor. 2.4 Adding files to CMakeLists At this point, we have created our config/overlay files. We must add these to our build system for any of them to take effect (if a file is named app.conf, it is picked up by the build system by default, as seen in CN.3-Serial_Console ). More details on this can be found here . vim CMakeLists.txt At the top of the file, append the following to add the newly created config files to CMakeLists. set(CONF_FILE usb.conf shell.conf) set(DTC_OVERLAY_FILE dtc_shell.overlay) 2.5 Initializing the Driver [main.c] At this point, ensure that there are no compile errors by running west build -p -b arduino_nano_33_ble and now we tell our application to initialize the USB stack. vim src/main.c #include <usb/usb_device.h> #include <drivers/uart.h> //Include these libraries //Add the following to main() void main ( void ) { /* Setup DTR */ const struct device * shell_dev = DEVICE_DT_GET ( DT_CHOSEN ( zephyr_shell_uart )); uint32_t dtr = 0 ; /* Enable the USB Driver */ if ( usb_enable ( NULL )) return ; /* Wait on DTR - 'Data Terminal Ready' * Will wait here until a terminal has been attached to the device * This is not necessary, however, can be useful for printing boot info etc.. */ while ( ! dtr ) { uart_line_ctrl_get ( shell_dev , UART_LINE_CTRL_DTR , & dtr ); k_sleep ( K_MSEC ( 100 )); } while ( 1 ) { //printk(\"Hello World\\n\"); //This will get routed to the shell also (optional) k_sleep ( K_MSEC ( 500 )); } } 2.6 Testing This application can now be built and flashed using: west build -p auto -b arduino_nano_33_ble west flash --bossac = $HOME /csse4011/BOSSA/BOSSA/bin/bossac #Check the Path is correct Since this is now a 'new usb device' , you will need to pass through USB from your host machine to the VM to open the shell within your CSSE4011 VM Typically, you might have to unplug and reconnect the device for the pass through to take effect. Alternatively, you should be able to view the shell on the host machine also. See that the device is connected lsusb #Command to show currently attached USB devices Bus 001 Device 099 : ID c553:4011 Wilfred MK Arduino Nano BLE - Zephyr #You will see this if you added the USB OPTIONS from above First install screen (App that can monitor terminal) sudo apt-get install screen sudo screen /dev/ttyACM0 You can press 'tab' to see the currently enabled options through shell. [00:00:11.851,226] <inf> usb_cdc_acm: Device resumed [00:00:11.851,257] <inf> usb_cdc_acm: from suspend CSSE4011:~$ clear device devmem help history hwinfo kernel log nrf_clock_control resize shell CSSE4011:~$kernel threads Scheduler: 23890 since last call Threads: *0x20000438 shell_uart options: 0x0, priority: 14 timeout: 536872112 state: queued, entry: 0x13029 stack size 2048, unused 1176, usage 872 / 2048 (42 %) 2.7 Sample Application A sample application has been provided, this application includes all the steps mentioned above. You can test the shell by flashing it to the Arduino Sense Board. Sample is located in: REPO_TOP/tute_solutions/shell_example/","title":"4.0 Shell"},{"location":"Connectivity/CN.4-Shell/#csse4011-connectivity-shell","text":"The following tutorial will cover the setting up a command line interface/Shell through USB with existing Zephyr Drivers. (Note that, USB Debugging/Shell can only be used with platforms that support USB, such as the NRF52840 SoC).","title":"CSSE4011: Connectivity - Shell"},{"location":"Connectivity/CN.4-Shell/#10-motivation","text":"A shell or a command line interface (CLI) allows for a user to interact with the OS in real time. Shell commands can be used to issue unique commands to a device or change application logic. For example, a command to read run-time statistics of threads or to turn an led on or off etc... Zephyr also allows for Shell to be used as a backend for the Zephyr Logging API. The logging API is explored in CN.5-Logging .","title":"1.0 Motivation"},{"location":"Connectivity/CN.4-Shell/#11-test-hardware","text":"Arduino Sense Board mUSB Cable This implementation is valid for Zephyr RTOS Version 2.7.XX","title":"1.1 Test Hardware"},{"location":"Connectivity/CN.4-Shell/#12-prerequisites","text":"Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1 and BRD.1","title":"1.2. Prerequisites"},{"location":"Connectivity/CN.4-Shell/#13-setup","text":"Connect the Arduino sense board to the host machine and ensure that the development environment has access to the device (USB passthrough to virtual machine).","title":"1.3 Setup"},{"location":"Connectivity/CN.4-Shell/#20-zephyr-shell-implementation","text":"","title":"2.0 Zephyr Shell Implementation"},{"location":"Connectivity/CN.4-Shell/#21-boilerplate","text":"The following commands assume that you have setup your files/directories following the respective tutorial(s). Create a new application directory for a sample shell application. cd ~/csse4011/csse4011_repo/ mkdir -p apps/shell_sample/ For setting up a basic boilerplate for our application, we will use the provided blinky sample in Zephyr. cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky cp -R * ~/csse4011/csse4011_repo/apps/shell_sample/ cd ~/csse4011/csse4011_repo/apps/shell_sample/","title":"2.1 Boilerplate"},{"location":"Connectivity/CN.4-Shell/#22-enable-usb-drivers-prjconf","text":"To show a more structure approach to setting configs in Zephyr, in this tutorials we will explore the addition of segmented config files to the build system. Where each file represents a different subsystem. Such an approach improves modularity for bigger projects. First, we will enable the USB subsystem as before, These options can be found here , for diffrent subsystems. vim usb.conf #create a new .conf file for the USB subsystem Append the following, then save and exit the editor. #----------------------------------USB SETUP---------------------------------- CONFIG_USB_DEVICE_STACK=y CONFIG_USB_DEVICE_PRODUCT=\"Zephyr USB shell sample\" #----------------------------------------------------------------------------- #--------------------------------USB_OPTIONS---------------------------------- CONFIG_USB_DEVICE_PRODUCT=\"Arduino Nano BLE - Zephyr\" CONFIG_USB_DEVICE_MANUFACTURER=\"Wilfred MK\" CONFIG_USB_DEVICE_VID=0xC553 CONFIG_USB_DEVICE_PID=0x4011 #----------------------------------------------------------------------------- Next, we will enable Zephyr Shell, vim shell.conf #create a new .conf file for shell options append the following config settings. #-----------------------------SHELL_CONF-------------------------------------- CONFIG_SHELL_BACKEND_SERIAL_CHECK_DTR=y CONFIG_UART_LINE_CTRL=y CONFIG_SHELL_BACKEND_SERIAL_INIT_PRIORITY=51 CONFIG_SHELL=y CONFIG_SHELL_BACKENDS=y CONFIG_SHELL_BACKEND_SERIAL=y CONFIG_SHELL_PROMPT_UART=\"CSSE4011:~$\" CONFIG_SHELL_CMDS=y CONFIG_SHELL_TAB=y CONFIG_SHELL_TAB_AUTOCOMPLETION=y CONFIG_SHELL_VT100_COLORS=y CONFIG_KERNEL_SHELL=y #----------------------------------------------------------------------------- #-----------------------------SHELL_LOGGING----------------------------------- CONFIG_LOG=y CONFIG_LOG_PRINTK=y #----------------------------------------------------------------------------- Save the file and exit the editor.","title":"2.2 Enable USB Drivers [prj.conf]"},{"location":"Connectivity/CN.4-Shell/#23-shell-usb-overlay","text":"As with the console, we must inform Zephyr that the shell-uart is to be routed through the USB subsystem using CDC_ACM . This can be done by creating and adding an overlay file to the build-system. An ' app.overlay' file can be created similarly to the console tutorial, and this will automatically be picked up by the build-system . However, here we will explore manually adding it to the build system. vim dtc_shell.overlay #create new file for shell overlay append the following to the file. / { chosen { zephyr , shell-uart = & cdc_acm_uart0 ; }; }; & zephyr_udc0 { cdc_acm_uart0 : cdc_acm_uart0 { compatible = \"zephyr,cdc-acm-uart\" ; label = \"CDC_ACM_0\" ; }; }; Save and exit the editor.","title":"2.3 Shell USB Overlay"},{"location":"Connectivity/CN.4-Shell/#24-adding-files-to-cmakelists","text":"At this point, we have created our config/overlay files. We must add these to our build system for any of them to take effect (if a file is named app.conf, it is picked up by the build system by default, as seen in CN.3-Serial_Console ). More details on this can be found here . vim CMakeLists.txt At the top of the file, append the following to add the newly created config files to CMakeLists. set(CONF_FILE usb.conf shell.conf) set(DTC_OVERLAY_FILE dtc_shell.overlay)","title":"2.4 Adding files to CMakeLists"},{"location":"Connectivity/CN.4-Shell/#25-initializing-the-driver-mainc","text":"At this point, ensure that there are no compile errors by running west build -p -b arduino_nano_33_ble and now we tell our application to initialize the USB stack. vim src/main.c #include <usb/usb_device.h> #include <drivers/uart.h> //Include these libraries //Add the following to main() void main ( void ) { /* Setup DTR */ const struct device * shell_dev = DEVICE_DT_GET ( DT_CHOSEN ( zephyr_shell_uart )); uint32_t dtr = 0 ; /* Enable the USB Driver */ if ( usb_enable ( NULL )) return ; /* Wait on DTR - 'Data Terminal Ready' * Will wait here until a terminal has been attached to the device * This is not necessary, however, can be useful for printing boot info etc.. */ while ( ! dtr ) { uart_line_ctrl_get ( shell_dev , UART_LINE_CTRL_DTR , & dtr ); k_sleep ( K_MSEC ( 100 )); } while ( 1 ) { //printk(\"Hello World\\n\"); //This will get routed to the shell also (optional) k_sleep ( K_MSEC ( 500 )); } }","title":"2.5 Initializing the Driver [main.c]"},{"location":"Connectivity/CN.4-Shell/#26-testing","text":"This application can now be built and flashed using: west build -p auto -b arduino_nano_33_ble west flash --bossac = $HOME /csse4011/BOSSA/BOSSA/bin/bossac #Check the Path is correct Since this is now a 'new usb device' , you will need to pass through USB from your host machine to the VM to open the shell within your CSSE4011 VM Typically, you might have to unplug and reconnect the device for the pass through to take effect. Alternatively, you should be able to view the shell on the host machine also. See that the device is connected lsusb #Command to show currently attached USB devices Bus 001 Device 099 : ID c553:4011 Wilfred MK Arduino Nano BLE - Zephyr #You will see this if you added the USB OPTIONS from above First install screen (App that can monitor terminal) sudo apt-get install screen sudo screen /dev/ttyACM0 You can press 'tab' to see the currently enabled options through shell. [00:00:11.851,226] <inf> usb_cdc_acm: Device resumed [00:00:11.851,257] <inf> usb_cdc_acm: from suspend CSSE4011:~$ clear device devmem help history hwinfo kernel log nrf_clock_control resize shell CSSE4011:~$kernel threads Scheduler: 23890 since last call Threads: *0x20000438 shell_uart options: 0x0, priority: 14 timeout: 536872112 state: queued, entry: 0x13029 stack size 2048, unused 1176, usage 872 / 2048 (42 %)","title":"2.6 Testing"},{"location":"Connectivity/CN.4-Shell/#27-sample-application","text":"A sample application has been provided, this application includes all the steps mentioned above. You can test the shell by flashing it to the Arduino Sense Board. Sample is located in: REPO_TOP/tute_solutions/shell_example/","title":"2.7 Sample Application"},{"location":"Connectivity/CN.4.1-Shell_Commands/","text":"CSSE4011: Connectivity - Shell Commands This tutorial aims to introduce adding shell commands to the Zephyr shell that we explored in CN.4-Shell . 1.0 Motivation To get the most out of an application that implement a shell, it is often useful to add specific functionality. By adding application specific shell commands, specific features of an application can be exposed to a user/developer. Typically, a command will hook into a piece of code or a callback function and execute some functionality for that command. For instance, in a embedded application, if the user aims to turn some hardware off, you could issue a shell command to the device to carry this out, or if you wanted to get a reading from a sensor and print it to the shell, you could issue a command to do this. Similar to how in a unix based shell you would issue commands to interact/request services from the OS. 1.1 Test Hardware Arduino Sense Board mUSB Cable This implementation is valid for Zephyr RTOS Version 2.7.XX 1.2. Prerequisites Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1, BRD.1 and CN.4-Shell 1.3 Setup Connect the Arduino sense board to the host machine and ensure that the development environment has access to the device (USB passthrough to virtual machine). 2.0 Zephyr Shell Command Implementation 2.1 Boilerplate In the previous tutorial (CN.4 - Shell) we set up the Zephyr Shell through USB. We will use that as our boilerplate for this tutorial and add to it the functionality required to implement shell commands. The following commands assume that you have setup your files/directories following the respective tutorial(s). cd ~/csse4011/csse4011_repo/apps mkdir shell_cmd_sample/ Copy shell sample files (from CN.4 - Shell ) into new directory for shell commands cd -R shell_sample/* shell_cmd_sample/ 2.1 Implementing a Shell Command In this tutorial, we will explore using shell commands, to toggle on and off the onboard led. This should give you a general idea of how commands should be implemented/used. For more information on the following see here . Zephyr allows you to create commands that have sub-commands, these can be useful for instance, if you wanted a top level command ( root command - level 0 ) for a particular sub-system/hardware, and then sub-commands ( static/dynamic sub-commands - level > 0 ) that perform unique a function for that system. It can be thought of as a tree of commands. Here, we will look at creating a root command (led) with two static commands (on/off). However, you can refer here [1] for the api guide for more information on other types of commands. First, cd shell_cmd_sample/ vim src/main.c add the shell include #include <shell/shell.h> Now we can specify what commands we are going to make, using the Shell API macros SHELL_CMD_REGISTER() and SHELL_STATIC_SUBCMD_SET_CREATE() Let's first declare some prototype handlers for our commands /* Declare command handler prototypes */ static int cmd_led_ctrl_on ( const struct shell * , size_t , char ** ); static int cmd_led_ctrl_off ( const struct shell * , size_t , char ** ); and let's use the macros to setup our commands. /* Specify Shell Commands for LED Toggling */ /* Creating subcommands (level 1 command) array for command \"led\". */ SHELL_STATIC_SUBCMD_SET_CREATE ( led_ctrl , SHELL_CMD ( on , NULL , \"Turn led on.\" , cmd_led_ctrl_on ), SHELL_CMD ( off , NULL , \"Turn led off.\" , cmd_led_ctrl_off ), SHELL_SUBCMD_SET_END ); /* Creating root (level 0) command \"led\" */ SHELL_CMD_REGISTER ( led , & led_ctrl , \"Led Control (On/Off)\" , NULL ); SHELL_CMD_REGISTER() creates out root level command for led , and SHELL_STATIC_SUBCMD_SET_CREATE() create the level 1 subcommands for on and off , which are linked to their respective command handlers cmd_led_ctrl_on and cmd_led_ctrl_off . That is, when a user types led off , the cmd_led_ctrl_off is triggered. Finally, we can implement the actual handlers. Note, that these don't check if the led-gpio pin has been initialized and assumes it has been pre-configured in main() (if not, gpio_pin_set() will fail). /* Command Handler for toggling led0 on, note that it assumes * the pin has been preconfigured */ static int cmd_led_ctrl_on ( const struct shell * shell , size_t argc , char ** argv ) { ARG_UNUSED ( argc ); ARG_UNUSED ( argv ); const struct device * dev = device_get_binding ( LED0 ); if ( dev == NULL ) { return ENODEV ; } /* Pin default is Active low (as per FLAGS) */ return gpio_pin_set ( dev , PIN , ( int ) 0 ); } /* Command Handler for toggling led0 off, note that it assumes * the pin has been preconfigured */ static int cmd_led_ctrl_off ( const struct shell * shell , size_t argc , char ** argv ) { ARG_UNUSED ( argc ); ARG_UNUSED ( argv ); const struct device * dev = device_get_binding ( LED0 ); if ( dev == NULL ) { return ENODEV ; } /* Pin default is active low */ return gpio_pin_set ( dev , PIN , ( int ) 1 ); } Since we copied the boilerplate from CN-4 Shell , make sure to cleanup the while() loop in main() that toggles the gpio, but leave the code that initializes the led-gpio pin . Alternatively, you could make two other subcommands to init/deinit the pin. 2.2 Testing Once you have built and flashed the application, attach screen to the device. In the shell, you can press tab to show available commands. You should be able to see one that says led now. Try led --help to see what it can do, then, led on , this should turn the led on. [00:00:00.234,588] <inf> usb_cdc_acm: Device resumed [00:00:00.429,962] <inf> usb_cdc_acm: Device configured CSSE4011:~$ clear device devmem help history hwinfo kernel led log nrf_clock_control resize shell CSSE4011:~$led --help led - Led Control (On/Off) Subcommands: on :Turn led on. off :Turn led off. CSSE4011:~$ CSSE4011:~$led on CSSE4011:~$led off 3.0 Sample Application A sample application has been provided, this application includes all the steps mentioned above. You can test the shell commands to toggle the onboard led by flashing it to the Arduino Sense Board. Sample is located in: REPO_TOP/tute_solutions/shell_cmd_sample/","title":"4.1 Shell Commands"},{"location":"Connectivity/CN.4.1-Shell_Commands/#csse4011-connectivity-shell-commands","text":"This tutorial aims to introduce adding shell commands to the Zephyr shell that we explored in CN.4-Shell .","title":"CSSE4011: Connectivity - Shell Commands"},{"location":"Connectivity/CN.4.1-Shell_Commands/#10-motivation","text":"To get the most out of an application that implement a shell, it is often useful to add specific functionality. By adding application specific shell commands, specific features of an application can be exposed to a user/developer. Typically, a command will hook into a piece of code or a callback function and execute some functionality for that command. For instance, in a embedded application, if the user aims to turn some hardware off, you could issue a shell command to the device to carry this out, or if you wanted to get a reading from a sensor and print it to the shell, you could issue a command to do this. Similar to how in a unix based shell you would issue commands to interact/request services from the OS.","title":"1.0 Motivation"},{"location":"Connectivity/CN.4.1-Shell_Commands/#11-test-hardware","text":"Arduino Sense Board mUSB Cable This implementation is valid for Zephyr RTOS Version 2.7.XX","title":"1.1 Test Hardware"},{"location":"Connectivity/CN.4.1-Shell_Commands/#12-prerequisites","text":"Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1, BRD.1 and CN.4-Shell","title":"1.2. Prerequisites"},{"location":"Connectivity/CN.4.1-Shell_Commands/#13-setup","text":"Connect the Arduino sense board to the host machine and ensure that the development environment has access to the device (USB passthrough to virtual machine).","title":"1.3 Setup"},{"location":"Connectivity/CN.4.1-Shell_Commands/#20-zephyr-shell-command-implementation","text":"","title":"2.0 Zephyr Shell Command Implementation"},{"location":"Connectivity/CN.4.1-Shell_Commands/#21-boilerplate","text":"In the previous tutorial (CN.4 - Shell) we set up the Zephyr Shell through USB. We will use that as our boilerplate for this tutorial and add to it the functionality required to implement shell commands. The following commands assume that you have setup your files/directories following the respective tutorial(s). cd ~/csse4011/csse4011_repo/apps mkdir shell_cmd_sample/ Copy shell sample files (from CN.4 - Shell ) into new directory for shell commands cd -R shell_sample/* shell_cmd_sample/","title":"2.1 Boilerplate"},{"location":"Connectivity/CN.4.1-Shell_Commands/#21-implementing-a-shell-command","text":"In this tutorial, we will explore using shell commands, to toggle on and off the onboard led. This should give you a general idea of how commands should be implemented/used. For more information on the following see here . Zephyr allows you to create commands that have sub-commands, these can be useful for instance, if you wanted a top level command ( root command - level 0 ) for a particular sub-system/hardware, and then sub-commands ( static/dynamic sub-commands - level > 0 ) that perform unique a function for that system. It can be thought of as a tree of commands. Here, we will look at creating a root command (led) with two static commands (on/off). However, you can refer here [1] for the api guide for more information on other types of commands. First, cd shell_cmd_sample/ vim src/main.c add the shell include #include <shell/shell.h> Now we can specify what commands we are going to make, using the Shell API macros SHELL_CMD_REGISTER() and SHELL_STATIC_SUBCMD_SET_CREATE() Let's first declare some prototype handlers for our commands /* Declare command handler prototypes */ static int cmd_led_ctrl_on ( const struct shell * , size_t , char ** ); static int cmd_led_ctrl_off ( const struct shell * , size_t , char ** ); and let's use the macros to setup our commands. /* Specify Shell Commands for LED Toggling */ /* Creating subcommands (level 1 command) array for command \"led\". */ SHELL_STATIC_SUBCMD_SET_CREATE ( led_ctrl , SHELL_CMD ( on , NULL , \"Turn led on.\" , cmd_led_ctrl_on ), SHELL_CMD ( off , NULL , \"Turn led off.\" , cmd_led_ctrl_off ), SHELL_SUBCMD_SET_END ); /* Creating root (level 0) command \"led\" */ SHELL_CMD_REGISTER ( led , & led_ctrl , \"Led Control (On/Off)\" , NULL ); SHELL_CMD_REGISTER() creates out root level command for led , and SHELL_STATIC_SUBCMD_SET_CREATE() create the level 1 subcommands for on and off , which are linked to their respective command handlers cmd_led_ctrl_on and cmd_led_ctrl_off . That is, when a user types led off , the cmd_led_ctrl_off is triggered. Finally, we can implement the actual handlers. Note, that these don't check if the led-gpio pin has been initialized and assumes it has been pre-configured in main() (if not, gpio_pin_set() will fail). /* Command Handler for toggling led0 on, note that it assumes * the pin has been preconfigured */ static int cmd_led_ctrl_on ( const struct shell * shell , size_t argc , char ** argv ) { ARG_UNUSED ( argc ); ARG_UNUSED ( argv ); const struct device * dev = device_get_binding ( LED0 ); if ( dev == NULL ) { return ENODEV ; } /* Pin default is Active low (as per FLAGS) */ return gpio_pin_set ( dev , PIN , ( int ) 0 ); } /* Command Handler for toggling led0 off, note that it assumes * the pin has been preconfigured */ static int cmd_led_ctrl_off ( const struct shell * shell , size_t argc , char ** argv ) { ARG_UNUSED ( argc ); ARG_UNUSED ( argv ); const struct device * dev = device_get_binding ( LED0 ); if ( dev == NULL ) { return ENODEV ; } /* Pin default is active low */ return gpio_pin_set ( dev , PIN , ( int ) 1 ); } Since we copied the boilerplate from CN-4 Shell , make sure to cleanup the while() loop in main() that toggles the gpio, but leave the code that initializes the led-gpio pin . Alternatively, you could make two other subcommands to init/deinit the pin.","title":"2.1 Implementing a Shell Command"},{"location":"Connectivity/CN.4.1-Shell_Commands/#22-testing","text":"Once you have built and flashed the application, attach screen to the device. In the shell, you can press tab to show available commands. You should be able to see one that says led now. Try led --help to see what it can do, then, led on , this should turn the led on. [00:00:00.234,588] <inf> usb_cdc_acm: Device resumed [00:00:00.429,962] <inf> usb_cdc_acm: Device configured CSSE4011:~$ clear device devmem help history hwinfo kernel led log nrf_clock_control resize shell CSSE4011:~$led --help led - Led Control (On/Off) Subcommands: on :Turn led on. off :Turn led off. CSSE4011:~$ CSSE4011:~$led on CSSE4011:~$led off","title":"2.2 Testing"},{"location":"Connectivity/CN.4.1-Shell_Commands/#30-sample-application","text":"A sample application has been provided, this application includes all the steps mentioned above. You can test the shell commands to toggle the onboard led by flashing it to the Arduino Sense Board. Sample is located in: REPO_TOP/tute_solutions/shell_cmd_sample/","title":"3.0 Sample Application"},{"location":"Connectivity/CN.5-Logging/","text":"CSSE4011: Connectivity - Loggging 1.0 Motivation The aim of this tutorial is to introduce the Zephyr Logging Api. Logging in an application can be used for for implementing debugging, providing status updates and other general information. In complex systems, logging is often implemented and is a fundamental part of providing a robust application. Using the Zephyr logging api, this tutorial will introduce how to implement logging in an application. Typically, logging is coupled with a command line interface. In addition to the previous tutorial CN.4-Shell , we will append the logging subsystem on to our shell. 1.1 Test Hardware Arduino Sense Board mUSB Cable This implementation is valid for Zephyr RTOS Version 2.7.XX 1.2. Prerequisites Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1 , BRD.1 and CN.4-Shell. 2.0 Zephyr Logging Implementation 2.1 Boilerplate The following commands assume that you have setup your files/directories following the respective tutorial(s). Create a new application directory for a sample shell application. cd ~/csse4011/csse4011_repo/ mkdir -p apps/logging_sample/ Here we will a copy of the previous shell sample and add to it. You may also use the provided shell solution. cd shell_example/ cp -R * ../shell_sample/ cd ~/csse4011/csse4011_repo/apps/shell_sample/ 2.2 Driver and Config Setup Since we are appending to our existing solution of the shell sample, we do need additional overlays or config options here. It is worth noting that in shell.conf the following lines enable logging. Here, the shell is set default as the backend for logging (preset in Kconfig options: CONFIG_SHELL_LOG_BACKEND [1]). #-----------------------------SHELL_LOGGING----------------------------------- CONFIG_LOG=y CONFIG_LOG_PRINTK=y #----------------------------------------------------------------------------- This also shows the simplicity of Zephyr, once an application is setup, using Zephyr features is as simple as adding config options (for the most part anyway...)! 3.0 Using the Logging API The API guide for logging can be found here , it is suggested that you read through it and understand the implementation options that logging can provide. 3.1 Register a Module A log module must be declared prior to using logging in an application. These modules may represent a device driver or a particular sub-system. For instance, you may define a module for a particular temperature sensor driver -- any logged output from this driver will now contain a signature referring to the name of the respective module. Since we only have the one source file, we will define only one module. The API guide has more information on how to use this across multiple files using different macros. It is simple to setup and highly suggested for your projects. Start by editing our source file. vim src/main.c append the following. #include <logging/log.h> /* Define logging module */ LOG_MODULE_REGISTER ( sample_module ); //OR LOG_MODULE_REGISTER ( sample_module , LOG_LEVEL_DBG ); This registers a module names sample_module with a log filter level of DEBUG (this is optional). 3.2 Using a Module Once a module as been registered as above, we can use the following macros to implement the logging. Keep in mind that if you have set a LOG_LEVEL_X some of these may be filtered out. LOG_ERR ( \"Some error message: %d\" , errno ); LOG_WRN ( \"It's getting hot in here...\" ); LOG_INF ( \"The table is made out of...table\" ); LOG_DBG ( \"Read 0x8F register value: %ld\" , rVal ); Refer to the API guide , for more useful logging macros. In our main.c file, we can add in some logging options. ... ... while ( 1 ) { gpio_pin_set ( dev , PIN , ( int ) led_is_on ); led_is_on = ! led_is_on ; LOG_INF ( \"Led is currently: %s\" , led_is_on ? \"On\" : \"Off\" ); k_sleep ( K_SECONDS ( 5 )); } 4.0 Testing This application can now be built and flashed using: west build -p auto -b arduino_nano_33_ble west flash --bossac = $HOME /csse4011/BOSSA/BOSSA/bin/bossac #Check the Path is correct Once flashed, sudo screen /dev/ttyACM0 ... ... [00:00:03.203,369] <dbg> sample_module.main: DTR OK [00:00:03.203,369] <inf> sample_module: Led is currently: Off [00:00:08.203,430] <inf> sample_module: Led is currently: On 4.1 Sample Application A sample application has been provided, this application includes all the steps mentioned above. You can test the shell by flashing it to the Arduino Sense Board. Sample is located in: REPO_TOP/tute_solutions/logging_example/","title":"5.0 Logging"},{"location":"Connectivity/CN.5-Logging/#csse4011-connectivity-loggging","text":"","title":"CSSE4011: Connectivity - Loggging"},{"location":"Connectivity/CN.5-Logging/#10-motivation","text":"The aim of this tutorial is to introduce the Zephyr Logging Api. Logging in an application can be used for for implementing debugging, providing status updates and other general information. In complex systems, logging is often implemented and is a fundamental part of providing a robust application. Using the Zephyr logging api, this tutorial will introduce how to implement logging in an application. Typically, logging is coupled with a command line interface. In addition to the previous tutorial CN.4-Shell , we will append the logging subsystem on to our shell.","title":"1.0 Motivation"},{"location":"Connectivity/CN.5-Logging/#11-test-hardware","text":"Arduino Sense Board mUSB Cable This implementation is valid for Zephyr RTOS Version 2.7.XX","title":"1.1 Test Hardware"},{"location":"Connectivity/CN.5-Logging/#12-prerequisites","text":"Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1 , BRD.1 and CN.4-Shell.","title":"1.2. Prerequisites"},{"location":"Connectivity/CN.5-Logging/#20-zephyr-logging-implementation","text":"","title":"2.0 Zephyr Logging Implementation"},{"location":"Connectivity/CN.5-Logging/#21-boilerplate","text":"The following commands assume that you have setup your files/directories following the respective tutorial(s). Create a new application directory for a sample shell application. cd ~/csse4011/csse4011_repo/ mkdir -p apps/logging_sample/ Here we will a copy of the previous shell sample and add to it. You may also use the provided shell solution. cd shell_example/ cp -R * ../shell_sample/ cd ~/csse4011/csse4011_repo/apps/shell_sample/","title":"2.1 Boilerplate"},{"location":"Connectivity/CN.5-Logging/#22-driver-and-config-setup","text":"Since we are appending to our existing solution of the shell sample, we do need additional overlays or config options here. It is worth noting that in shell.conf the following lines enable logging. Here, the shell is set default as the backend for logging (preset in Kconfig options: CONFIG_SHELL_LOG_BACKEND [1]). #-----------------------------SHELL_LOGGING----------------------------------- CONFIG_LOG=y CONFIG_LOG_PRINTK=y #----------------------------------------------------------------------------- This also shows the simplicity of Zephyr, once an application is setup, using Zephyr features is as simple as adding config options (for the most part anyway...)!","title":"2.2 Driver and Config Setup"},{"location":"Connectivity/CN.5-Logging/#30-using-the-logging-api","text":"The API guide for logging can be found here , it is suggested that you read through it and understand the implementation options that logging can provide.","title":"3.0 Using the Logging API"},{"location":"Connectivity/CN.5-Logging/#31-register-a-module","text":"A log module must be declared prior to using logging in an application. These modules may represent a device driver or a particular sub-system. For instance, you may define a module for a particular temperature sensor driver -- any logged output from this driver will now contain a signature referring to the name of the respective module. Since we only have the one source file, we will define only one module. The API guide has more information on how to use this across multiple files using different macros. It is simple to setup and highly suggested for your projects. Start by editing our source file. vim src/main.c append the following. #include <logging/log.h> /* Define logging module */ LOG_MODULE_REGISTER ( sample_module ); //OR LOG_MODULE_REGISTER ( sample_module , LOG_LEVEL_DBG ); This registers a module names sample_module with a log filter level of DEBUG (this is optional).","title":"3.1 Register a Module"},{"location":"Connectivity/CN.5-Logging/#32-using-a-module","text":"Once a module as been registered as above, we can use the following macros to implement the logging. Keep in mind that if you have set a LOG_LEVEL_X some of these may be filtered out. LOG_ERR ( \"Some error message: %d\" , errno ); LOG_WRN ( \"It's getting hot in here...\" ); LOG_INF ( \"The table is made out of...table\" ); LOG_DBG ( \"Read 0x8F register value: %ld\" , rVal ); Refer to the API guide , for more useful logging macros. In our main.c file, we can add in some logging options. ... ... while ( 1 ) { gpio_pin_set ( dev , PIN , ( int ) led_is_on ); led_is_on = ! led_is_on ; LOG_INF ( \"Led is currently: %s\" , led_is_on ? \"On\" : \"Off\" ); k_sleep ( K_SECONDS ( 5 )); }","title":"3.2 Using a Module"},{"location":"Connectivity/CN.5-Logging/#40-testing","text":"This application can now be built and flashed using: west build -p auto -b arduino_nano_33_ble west flash --bossac = $HOME /csse4011/BOSSA/BOSSA/bin/bossac #Check the Path is correct Once flashed, sudo screen /dev/ttyACM0 ... ... [00:00:03.203,369] <dbg> sample_module.main: DTR OK [00:00:03.203,369] <inf> sample_module: Led is currently: Off [00:00:08.203,430] <inf> sample_module: Led is currently: On","title":"4.0 Testing"},{"location":"Connectivity/CN.5-Logging/#41-sample-application","text":"A sample application has been provided, this application includes all the steps mentioned above. You can test the shell by flashing it to the Arduino Sense Board. Sample is located in: REPO_TOP/tute_solutions/logging_example/","title":"4.1 Sample Application"},{"location":"Connectivity/CN.6-Segger_RTT/","text":"CSSE4011: Connectivity - Using Segger RTT 1.0 Motivation Aim of this tutorial is to use Segger RTT for serial access on devices where USB is not available. For instance, the Thingy52, has an nRF52832 SOC, which does not support USB-D. To debug such a device, where a JTAG is exposed, we can configure the Zephyr kernel to backend a shell or a console to Segger RTT. 1.1 Test Hardware Thingy52 or Particle Argon 2x mUSB Cable Segger JLinkEDUMini 1.2. Prerequisites Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1 and BRD.2 1.3 Setup Connect the the JLinkEdu mini to the Thingy52 and to your VM (with USB passthrough). Make sure that the Thingy52 is powered on (switch in left position, when looking directly at it) and connected to a PC for charging the battery. 2.0 Zephyr Console - Segger RTT Implementation The following commands assume that you have setup your files/directories following the respective tutorial(s). 2.1 Boilerplate Start by making setting up a sample Zephyr application as we have done before. You could use the blinkly provided sample in the Zephyr source. cd ~/csse4011/csse4011_repo/apps mkdir segger_rtt_console/ Use the boilerplate from blinky to setup the application directory cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky cp -R * ~/csse4011/csse4011_repo/apps/segger_rtt_console/ cd ~/csse4011/csse4011_repo/apps/segger_rtt_console/ 2.2 Add Segger RTT KConf for Console We'll create a new config file. vim segger_rtt_console.conf and add in: #-----------------------------RTT_CONFIG-------------------------------------- CONFIG_USE_SEGGER_RTT=y CONFIG_RTT_CONSOLE=y CONFIG_UART_CONSOLE=n #----------------------------------------------------------------------------- 2.3 Add KConf to CMakeLists Now, we will add these to the build system (as per OS2.1 - Building Tips ) vim CMakeLists.txt set ( CONF_FILE segger_rtt.conf ) Now you can compile and flash this application. See below 4.0 Testing for more. Be sure to add a printk() , so you can see some output in the console. while ( 1 ) { printk ( \"Out like a light \\n \" ); k_msleep ( 500 ); } 3.0 Zephyr Shell - Segger RTT Implementation The following commands assume that you have setup your files/directories following the respective tutorial(s). 3.1 Boilerplate Start by making setting up a sample Zephyr application as we have done before. You could use the blinkly provided sample in the Zephyr source. cd ~/csse4011/csse4011_repo/apps mkdir segger_rtt_shell/ Use the boilerplate from blinky to setup the application directory cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky cp -R * ~/csse4011/csse4011_repo/apps/segger_rtt_shell/ cd ~/csse4011/csse4011_repo/apps/segger_rtt_shell/ 3.2 Add Segger RTT KConf for Shell We'll create a new config file. vim segger_rtt_shell.conf And add these options into tell the kernel we want to use these features. #-----------------------------RTT_CONFIG-------------------------------------- CONFIG_USE_SEGGER_RTT=y CONFIG_SHELL_BACKEND_RTT=y #----------------------------------------------------------------------------- Since we are using the shell, we will also need to configure it (same config as in CN.4 - Shell ). To summarize: vim shell.conf and add the following #-----------------------------SHELL_CONF-------------------------------------- CONFIG_SHELL_BACKEND_SERIAL_CHECK_DTR=y CONFIG_UART_LINE_CTRL=y CONFIG_SHELL_BACKEND_SERIAL_INIT_PRIORITY=51 CONFIG_SHELL=y CONFIG_SHELL_BACKENDS=y CONFIG_SHELL_BACKEND_SERIAL=y CONFIG_SHELL_PROMPT_RTT=\"CSSE4011:~$\" CONFIG_SHELL_CMDS=y CONFIG_SHELL_TAB=y CONFIG_SHELL_TAB_AUTOCOMPLETION=y CONFIG_SHELL_VT100_COLORS=y CONFIG_KERNEL_SHELL=y #----------------------------------------------------------------------------- #-----------------------------SHELL_LOGGING----------------------------------- CONFIG_LOG=y CONFIG_LOG_PRINTK=y #----------------------------------------------------------------------------- 3.3 Add KConf to CMakeLists Now, we will add these to the build system (as per OS2.1 - Building Tips ) vim CMakeLists.txt set ( CONF_FILE shell.conf segger_rtt.conf ) Now you can compile and flash this application. 4.0 Testing To connect to the Segger RTT target, open up a terminal and use the following command JLinkRTTLogger -Device NRF52840_XXAA -RTTChannel 1 -if SWD -Speed 4000 ~/rtt.log You should see something like.... ------------------------------------------------------------ Connected to: J-Link EDU Mini V1 compiled Dec 7 2021 08:38:51 S/N: 801026632 Searching for RTT Control Block...OK. 3 up-channels found: 0: Terminal 1: 2: Selected RTT Channel description: Index: 1 Name: Size: 0 bytes. Output file: /home/twilfred/rtt.log Getting RTT data from target. Press any key to quit. ------------------------------------------------------------ at this point, open up another terminal and nc localhost 19021 If you setup a console, you should see: SEGGER J-Link V7.58c - Real time terminal output J-Link EDU Mini V1 compiled Dec 7 2021 08:38:51 V1.0, SN=801026632 Process: JLinkRTTLoggerExe *** Booting Zephyr OS build zephyr-v2.7.0 *** and any printk() used after the bootbanner. If you had setup a shell, you should see the shell prompt, where you can now enter commands and/or see logging outputs. 5.0 Troubleshooting Make sure that your VM has access to the JLink (USB Passthrough), Test with: lsusb $ lsusb $ Bus 001 Device 003: ID 1366:0101 SEGGER J-Link PLUS If this fails: JLinkRTTLogger -Device NRF52840_XXAA -RTTChannel 1 -if SWD -Speed 4000 ~/rtt.log Try setting the -RTTChannel 0 JLinkRTTLogger -Device NRF52840_XXAA -RTTChannel 0 -if SWD -Speed 4000 ~/rtt.log If a shell prompt doesn't come up at first, in the nc window. Try pressing enter a few times. 6.0 Sample Applications Sample applications (shell/console) have been provided, these applications include all the steps mentioned above. You can test your devices with using these apps. Shell sample is located in REPO_TOP/tute_solutions/segger_rtt_shell/ Console sample is located in: REPO_TOP/tute_solutions/segger_rtt_console/","title":"6.0 Segger RTT"},{"location":"Connectivity/CN.6-Segger_RTT/#csse4011-connectivity-using-segger-rtt","text":"","title":"CSSE4011: Connectivity - Using Segger RTT"},{"location":"Connectivity/CN.6-Segger_RTT/#10-motivation","text":"Aim of this tutorial is to use Segger RTT for serial access on devices where USB is not available. For instance, the Thingy52, has an nRF52832 SOC, which does not support USB-D. To debug such a device, where a JTAG is exposed, we can configure the Zephyr kernel to backend a shell or a console to Segger RTT.","title":"1.0 Motivation"},{"location":"Connectivity/CN.6-Segger_RTT/#11-test-hardware","text":"Thingy52 or Particle Argon 2x mUSB Cable Segger JLinkEDUMini","title":"1.1 Test Hardware"},{"location":"Connectivity/CN.6-Segger_RTT/#12-prerequisites","text":"Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1 and BRD.2","title":"1.2. Prerequisites"},{"location":"Connectivity/CN.6-Segger_RTT/#13-setup","text":"Connect the the JLinkEdu mini to the Thingy52 and to your VM (with USB passthrough). Make sure that the Thingy52 is powered on (switch in left position, when looking directly at it) and connected to a PC for charging the battery.","title":"1.3 Setup"},{"location":"Connectivity/CN.6-Segger_RTT/#20-zephyr-console-segger-rtt-implementation","text":"The following commands assume that you have setup your files/directories following the respective tutorial(s).","title":"2.0 Zephyr Console - Segger RTT  Implementation"},{"location":"Connectivity/CN.6-Segger_RTT/#21-boilerplate","text":"Start by making setting up a sample Zephyr application as we have done before. You could use the blinkly provided sample in the Zephyr source. cd ~/csse4011/csse4011_repo/apps mkdir segger_rtt_console/ Use the boilerplate from blinky to setup the application directory cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky cp -R * ~/csse4011/csse4011_repo/apps/segger_rtt_console/ cd ~/csse4011/csse4011_repo/apps/segger_rtt_console/","title":"2.1 Boilerplate"},{"location":"Connectivity/CN.6-Segger_RTT/#22-add-segger-rtt-kconf-for-console","text":"We'll create a new config file. vim segger_rtt_console.conf and add in: #-----------------------------RTT_CONFIG-------------------------------------- CONFIG_USE_SEGGER_RTT=y CONFIG_RTT_CONSOLE=y CONFIG_UART_CONSOLE=n #-----------------------------------------------------------------------------","title":"2.2 Add Segger RTT KConf for Console"},{"location":"Connectivity/CN.6-Segger_RTT/#23-add-kconf-to-cmakelists","text":"Now, we will add these to the build system (as per OS2.1 - Building Tips ) vim CMakeLists.txt set ( CONF_FILE segger_rtt.conf ) Now you can compile and flash this application. See below 4.0 Testing for more. Be sure to add a printk() , so you can see some output in the console. while ( 1 ) { printk ( \"Out like a light \\n \" ); k_msleep ( 500 ); }","title":"2.3 Add KConf to CMakeLists"},{"location":"Connectivity/CN.6-Segger_RTT/#30-zephyr-shell-segger-rtt-implementation","text":"The following commands assume that you have setup your files/directories following the respective tutorial(s).","title":"3.0 Zephyr Shell - Segger RTT  Implementation"},{"location":"Connectivity/CN.6-Segger_RTT/#31-boilerplate","text":"Start by making setting up a sample Zephyr application as we have done before. You could use the blinkly provided sample in the Zephyr source. cd ~/csse4011/csse4011_repo/apps mkdir segger_rtt_shell/ Use the boilerplate from blinky to setup the application directory cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky cp -R * ~/csse4011/csse4011_repo/apps/segger_rtt_shell/ cd ~/csse4011/csse4011_repo/apps/segger_rtt_shell/","title":"3.1 Boilerplate"},{"location":"Connectivity/CN.6-Segger_RTT/#32-add-segger-rtt-kconf-for-shell","text":"We'll create a new config file. vim segger_rtt_shell.conf And add these options into tell the kernel we want to use these features. #-----------------------------RTT_CONFIG-------------------------------------- CONFIG_USE_SEGGER_RTT=y CONFIG_SHELL_BACKEND_RTT=y #----------------------------------------------------------------------------- Since we are using the shell, we will also need to configure it (same config as in CN.4 - Shell ). To summarize: vim shell.conf and add the following #-----------------------------SHELL_CONF-------------------------------------- CONFIG_SHELL_BACKEND_SERIAL_CHECK_DTR=y CONFIG_UART_LINE_CTRL=y CONFIG_SHELL_BACKEND_SERIAL_INIT_PRIORITY=51 CONFIG_SHELL=y CONFIG_SHELL_BACKENDS=y CONFIG_SHELL_BACKEND_SERIAL=y CONFIG_SHELL_PROMPT_RTT=\"CSSE4011:~$\" CONFIG_SHELL_CMDS=y CONFIG_SHELL_TAB=y CONFIG_SHELL_TAB_AUTOCOMPLETION=y CONFIG_SHELL_VT100_COLORS=y CONFIG_KERNEL_SHELL=y #----------------------------------------------------------------------------- #-----------------------------SHELL_LOGGING----------------------------------- CONFIG_LOG=y CONFIG_LOG_PRINTK=y #-----------------------------------------------------------------------------","title":"3.2 Add Segger RTT KConf for Shell"},{"location":"Connectivity/CN.6-Segger_RTT/#33-add-kconf-to-cmakelists","text":"Now, we will add these to the build system (as per OS2.1 - Building Tips ) vim CMakeLists.txt set ( CONF_FILE shell.conf segger_rtt.conf ) Now you can compile and flash this application.","title":"3.3 Add KConf to CMakeLists"},{"location":"Connectivity/CN.6-Segger_RTT/#40-testing","text":"To connect to the Segger RTT target, open up a terminal and use the following command JLinkRTTLogger -Device NRF52840_XXAA -RTTChannel 1 -if SWD -Speed 4000 ~/rtt.log You should see something like.... ------------------------------------------------------------ Connected to: J-Link EDU Mini V1 compiled Dec 7 2021 08:38:51 S/N: 801026632 Searching for RTT Control Block...OK. 3 up-channels found: 0: Terminal 1: 2: Selected RTT Channel description: Index: 1 Name: Size: 0 bytes. Output file: /home/twilfred/rtt.log Getting RTT data from target. Press any key to quit. ------------------------------------------------------------ at this point, open up another terminal and nc localhost 19021 If you setup a console, you should see: SEGGER J-Link V7.58c - Real time terminal output J-Link EDU Mini V1 compiled Dec 7 2021 08:38:51 V1.0, SN=801026632 Process: JLinkRTTLoggerExe *** Booting Zephyr OS build zephyr-v2.7.0 *** and any printk() used after the bootbanner. If you had setup a shell, you should see the shell prompt, where you can now enter commands and/or see logging outputs.","title":"4.0 Testing"},{"location":"Connectivity/CN.6-Segger_RTT/#50-troubleshooting","text":"Make sure that your VM has access to the JLink (USB Passthrough), Test with: lsusb $ lsusb $ Bus 001 Device 003: ID 1366:0101 SEGGER J-Link PLUS If this fails: JLinkRTTLogger -Device NRF52840_XXAA -RTTChannel 1 -if SWD -Speed 4000 ~/rtt.log Try setting the -RTTChannel 0 JLinkRTTLogger -Device NRF52840_XXAA -RTTChannel 0 -if SWD -Speed 4000 ~/rtt.log If a shell prompt doesn't come up at first, in the nc window. Try pressing enter a few times.","title":"5.0 Troubleshooting"},{"location":"Connectivity/CN.6-Segger_RTT/#60-sample-applications","text":"Sample applications (shell/console) have been provided, these applications include all the steps mentioned above. You can test your devices with using these apps. Shell sample is located in REPO_TOP/tute_solutions/segger_rtt_shell/ Console sample is located in: REPO_TOP/tute_solutions/segger_rtt_console/","title":"6.0 Sample Applications"},{"location":"Connectivity/about/","text":"Connectivity Documentation Summary The following set of tutorial aim to expose aspects of Zephyr RTOS and handle connectivity. Such as basic GPIO to more advance features like using a console, shell and a logging system. Topic Brief CN.1 - GPIO Exposing GPIO pins and toggling pins Using devicetree/macros to interface hardware to application(s) CN.3 - Serial Console Setting up a console through USB Using printk() and printing to console Specify hardware usage using device tree overlays CN.4 - Shell Setting up the Zephyr Shell through USB Use of kernel config files Specify hardware usage using device tree overlays CN.4 - Shell Commands Building on CN.4 to add shell commands Commands that can execute a particular subroutine Exposing the Zephyr Shell Command API CN.5 - Logging Expose Zephyr Logging sub-system Setup Shell as Logging backend Setup log modules and log filtering CN.6 - Using SEGGER RTT Using a Shell through RTT Using a Console through RTT","title":"Overview"},{"location":"Connectivity/about/#connectivity-documentation","text":"","title":"Connectivity Documentation"},{"location":"Connectivity/about/#summary","text":"The following set of tutorial aim to expose aspects of Zephyr RTOS and handle connectivity. Such as basic GPIO to more advance features like using a console, shell and a logging system.","title":"Summary"},{"location":"Connectivity/about/#topic-brief","text":"CN.1 - GPIO Exposing GPIO pins and toggling pins Using devicetree/macros to interface hardware to application(s) CN.3 - Serial Console Setting up a console through USB Using printk() and printing to console Specify hardware usage using device tree overlays CN.4 - Shell Setting up the Zephyr Shell through USB Use of kernel config files Specify hardware usage using device tree overlays CN.4 - Shell Commands Building on CN.4 to add shell commands Commands that can execute a particular subroutine Exposing the Zephyr Shell Command API CN.5 - Logging Expose Zephyr Logging sub-system Setup Shell as Logging backend Setup log modules and log filtering CN.6 - Using SEGGER RTT Using a Shell through RTT Using a Console through RTT","title":"Topic Brief"},{"location":"OS/OS.1-Getting_Started/","text":"CSSE4011: Tute 1 - Getting Started with Zephyr RTOS 1.0 Zephyr RTOS: Overview Zephyr Real-Time Operating System (RTOS) managed by the Linux foundation, is designed for connected and resource constrained embedded devices. Unlike many other real-time operating systems (like free-RTOS), Zephyr is more than just a kernel, it is a software eco-system. Zephyr integrates a broad range of functionality such as: Bluetooth LoRaWan USB / Serial Console / Shell(CLI) SPI/I2C/UART Flash Drivers Filesystems and more... Depending on what particular feature your application might require, Zephyr allows you to build a program using only the necessary functionality (i.e BLE), this can optimize the overall footprint of binary. This is done using config file(s) that we will cover in the coming tutorials. 1.1 Zephyr Kernel Overview The Zephyr kernel is similar to that of free-RTOS at a high level, in that it is primarily concerned with task-scheduling, inter-task communication and synchronization. Zephyr offers a pre-emptive scheduler, that is, the code context can change at anytime. Thread based, where 'threads' mean the same thing as a 'task' in free-RTOS. It is 'Soft' real-time provided by system ticks 1.2 Zephyr West Meta-Tool Zephyr includes a command line tool named west. This tool provides a multiple repository management system, and Zephyr uses west to provide conveniences for building, flashing, debugging and cleaning applications. For example, to build a program you could use, west build This will look at predefined build configuration settings and build an application as specified. The west meta-tool can be used to perform many other functions, see here for a detailed breakdown of it's features. In this course, you will be using west to build, flash and maintain your workspaces. 1.3 Zephyr Documentation The Zephyr documentation is well written and contains all the intricate details about Zephyr and it's features. Throughout this course and application development, you will need to refer back to these documentation to understand; The Build and Configuration Systems Device Tree (A way of describing hardware config to the OS) Application Development (App config options/Kernel config) API Usage Using an Interactive Kconfig interfaces (Optional) Take some time to read through these documents to get an idea of how Zephyr is implemented. This will be useful later when you are required to implement advanced features using Zephyr. 2.0 Installing Zephyr RTOS The following guide is made in reference to the Zephyr \"Getting Started Guide\" documentation , and is intended to be used on a Debian based linux distribution with the \"apt\" (package manager installed). First update the system and any installed packages on your VM sudo apt update sudo apt full-upgrade Reboot (If this was a fresh OS install, typically kernel is upgraded) sudo reboot [Skip kitware for Debian: This is for Ubuntu] Update sources list by adding the Kitware APT repo (contains cmake etc...) cd ~ wget https://apt.kitware.com/kitware-archive.sh sudo bash kitware-archive.sh sudo rm bash kitware-archive.sh - Remove script Install cmake, python3 and dtc (device tree compiler) sudo apt install --no-install-recommends git cmake ninja-build gperf \\ ccache dfu-util device-tree-compiler wget \\ python3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\ make gcc gcc-multilib g++-multilib libsdl2-dev [Installing CMAKE for Debian] sudo apt remove cmake - Remove out of date default package pip3 install cmake --upgrade - Install upto date CMAKE Log out and back in for pip3 app path to be exported into your environment. Verify dependencies are installed before continuing cmake --version python3 --version dtc --version 3.0 Get Zephyr and Install Python dependencies Install West (Zephyr Meta-tool) pip3 install --user -U west echo 'export PATH=~/.local/bin:\"$PATH\"' >> ~/.bashrc source ~/.bashrc Setup Zephyr Folder cd /home/user mkdir csse4011/ cd csse4011/ west init -m https://github.com/zephyrproject-rtos/zephyr --mr v2.7.1 zephyrproject or [this is not recommended, use latest stable v2.7.1 as above or v3.0.0] west init zephyrproject/ - Latest version of Zephyr ( the development tree ) Get Zephyr Source Code (Gets ALL of the source) cd zephyrproject west update - Might take awhile Export a Zephyr CMake package. This allows CMake to automatically load boilerplate code required for building Zephyr applications. west zephyr-export Zephyr\u2019s scripts/requirements.txt file declares additional Python dependencies. Install them with pip3. pip3 install --user -r ~/csse4011/zephyrproject/zephyr/scripts/requirements.txt 4.0 Installing the toolchains This tutorial will focus on installing the Zephyr SDK. You may also use 3rd party toolchains, however, for this course, the SDK will be sufficient. Note that Zephyr SDK is not available of Windows or MacOs. You will need to install a 3rd party toolchain, see here . Download the Zephyr SDK installer cd ~ wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.13.2/zephyr-sdk-0.13.2-linux-x86_64-setup.run Install the SDK to /opt/ , see here for other potential installation locations chmod +x zephyr-sdk-0.13.2-linux-x86_64-setup.run sudo ./zephyr-sdk-0.13.2-linux-x86_64-setup.run -- -d /opt/zephyr-sdk-0.13.2 Remove SDK Installer (Optional) cd ~ rm zephyr-sdk-0.13.2-linux-x86_64-setup.run Set udev rules, which allow you to flash most Zephyr boards as a regular user sudo cp /opt/zephyr-sdk-0.13.2/sysroots/x86_64-pokysdk-linux/usr/share/openocd/contrib/60-openocd.rules /etc/udev/rules.d sudo udevadm control --reload 5.0 Build a Sample Program (Blinky) If the installation was successful, we should now be able to build a basic blinky program. In the following command, the '-p auto' option automatically cleans byproducts from a previous build if necessary, which is useful if you try building another sample. The '-b' option specifies a board to build for, in this case the particle_boron, followed by the path to source. cd ~/csse4011/zephyrproject/zephyr/ west build -p auto -b particle_argon samples/basic/blinky Flash the sample program. Make a sure a 'runner' is connected. You will be given a Segger J-Link device to be used with the Particle Argon. west flash -r jlink Option '-r' specifies to flash using JLink, west is capable of tapping into different runners for flashing your devices, later we will explore how to specify runners in the CMakeLists file. If flashing fails, a runner may need to be installed. When using a Segger J-Link Device. Download and install the following JLink Software . Under 'J-Link Software and Documentation Pack', download the 'Linux - 64-bit DEB Installer'. Run the installer and install JLink software. Installation can be verified by running the following command from a terminal JLinkExe exit Additional information for setting up other runners can be found here 6.0 Setting Zephyr Base Setting $ZEPHYR_BASE allows you to invoke west from outside the source directory to build your applications. So we will add this environment to be set at login by bashrc . If you are using a different shell fish or zsh , make sure you set this within those config files. If you installed Zephyr elsewhere, adjust the following accordingly . echo \"# Add Zephyr Base Location to Path export ZEPHYR_BASE=~/csse4011/zephyrproject/zephyr\" >> ~/.bashrc source ~/.bashrc","title":"1.0 Getting Started"},{"location":"OS/OS.1-Getting_Started/#csse4011-tute-1-getting-started-with-zephyr-rtos","text":"","title":"CSSE4011: Tute 1 - Getting Started with Zephyr RTOS"},{"location":"OS/OS.1-Getting_Started/#10-zephyr-rtos-overview","text":"Zephyr Real-Time Operating System (RTOS) managed by the Linux foundation, is designed for connected and resource constrained embedded devices. Unlike many other real-time operating systems (like free-RTOS), Zephyr is more than just a kernel, it is a software eco-system. Zephyr integrates a broad range of functionality such as: Bluetooth LoRaWan USB / Serial Console / Shell(CLI) SPI/I2C/UART Flash Drivers Filesystems and more... Depending on what particular feature your application might require, Zephyr allows you to build a program using only the necessary functionality (i.e BLE), this can optimize the overall footprint of binary. This is done using config file(s) that we will cover in the coming tutorials.","title":"1.0 Zephyr RTOS: Overview"},{"location":"OS/OS.1-Getting_Started/#11-zephyr-kernel-overview","text":"The Zephyr kernel is similar to that of free-RTOS at a high level, in that it is primarily concerned with task-scheduling, inter-task communication and synchronization. Zephyr offers a pre-emptive scheduler, that is, the code context can change at anytime. Thread based, where 'threads' mean the same thing as a 'task' in free-RTOS. It is 'Soft' real-time provided by system ticks","title":"1.1 Zephyr Kernel Overview"},{"location":"OS/OS.1-Getting_Started/#12-zephyr-west-meta-tool","text":"Zephyr includes a command line tool named west. This tool provides a multiple repository management system, and Zephyr uses west to provide conveniences for building, flashing, debugging and cleaning applications. For example, to build a program you could use, west build This will look at predefined build configuration settings and build an application as specified. The west meta-tool can be used to perform many other functions, see here for a detailed breakdown of it's features. In this course, you will be using west to build, flash and maintain your workspaces.","title":"1.2 Zephyr West Meta-Tool"},{"location":"OS/OS.1-Getting_Started/#13-zephyr-documentation","text":"The Zephyr documentation is well written and contains all the intricate details about Zephyr and it's features. Throughout this course and application development, you will need to refer back to these documentation to understand; The Build and Configuration Systems Device Tree (A way of describing hardware config to the OS) Application Development (App config options/Kernel config) API Usage Using an Interactive Kconfig interfaces (Optional) Take some time to read through these documents to get an idea of how Zephyr is implemented. This will be useful later when you are required to implement advanced features using Zephyr.","title":"1.3 Zephyr Documentation"},{"location":"OS/OS.1-Getting_Started/#20-installing-zephyr-rtos","text":"The following guide is made in reference to the Zephyr \"Getting Started Guide\" documentation , and is intended to be used on a Debian based linux distribution with the \"apt\" (package manager installed). First update the system and any installed packages on your VM sudo apt update sudo apt full-upgrade Reboot (If this was a fresh OS install, typically kernel is upgraded) sudo reboot [Skip kitware for Debian: This is for Ubuntu] Update sources list by adding the Kitware APT repo (contains cmake etc...) cd ~ wget https://apt.kitware.com/kitware-archive.sh sudo bash kitware-archive.sh sudo rm bash kitware-archive.sh - Remove script Install cmake, python3 and dtc (device tree compiler) sudo apt install --no-install-recommends git cmake ninja-build gperf \\ ccache dfu-util device-tree-compiler wget \\ python3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\ make gcc gcc-multilib g++-multilib libsdl2-dev [Installing CMAKE for Debian] sudo apt remove cmake - Remove out of date default package pip3 install cmake --upgrade - Install upto date CMAKE Log out and back in for pip3 app path to be exported into your environment. Verify dependencies are installed before continuing cmake --version python3 --version dtc --version","title":"2.0 Installing Zephyr RTOS"},{"location":"OS/OS.1-Getting_Started/#30-get-zephyr-and-install-python-dependencies","text":"Install West (Zephyr Meta-tool) pip3 install --user -U west echo 'export PATH=~/.local/bin:\"$PATH\"' >> ~/.bashrc source ~/.bashrc Setup Zephyr Folder cd /home/user mkdir csse4011/ cd csse4011/ west init -m https://github.com/zephyrproject-rtos/zephyr --mr v2.7.1 zephyrproject or [this is not recommended, use latest stable v2.7.1 as above or v3.0.0] west init zephyrproject/ - Latest version of Zephyr ( the development tree ) Get Zephyr Source Code (Gets ALL of the source) cd zephyrproject west update - Might take awhile Export a Zephyr CMake package. This allows CMake to automatically load boilerplate code required for building Zephyr applications. west zephyr-export Zephyr\u2019s scripts/requirements.txt file declares additional Python dependencies. Install them with pip3. pip3 install --user -r ~/csse4011/zephyrproject/zephyr/scripts/requirements.txt","title":"3.0 Get Zephyr and Install Python dependencies"},{"location":"OS/OS.1-Getting_Started/#40-installing-the-toolchains","text":"This tutorial will focus on installing the Zephyr SDK. You may also use 3rd party toolchains, however, for this course, the SDK will be sufficient. Note that Zephyr SDK is not available of Windows or MacOs. You will need to install a 3rd party toolchain, see here . Download the Zephyr SDK installer cd ~ wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.13.2/zephyr-sdk-0.13.2-linux-x86_64-setup.run Install the SDK to /opt/ , see here for other potential installation locations chmod +x zephyr-sdk-0.13.2-linux-x86_64-setup.run sudo ./zephyr-sdk-0.13.2-linux-x86_64-setup.run -- -d /opt/zephyr-sdk-0.13.2 Remove SDK Installer (Optional) cd ~ rm zephyr-sdk-0.13.2-linux-x86_64-setup.run Set udev rules, which allow you to flash most Zephyr boards as a regular user sudo cp /opt/zephyr-sdk-0.13.2/sysroots/x86_64-pokysdk-linux/usr/share/openocd/contrib/60-openocd.rules /etc/udev/rules.d sudo udevadm control --reload","title":"4.0 Installing the toolchains"},{"location":"OS/OS.1-Getting_Started/#50-build-a-sample-program-blinky","text":"If the installation was successful, we should now be able to build a basic blinky program. In the following command, the '-p auto' option automatically cleans byproducts from a previous build if necessary, which is useful if you try building another sample. The '-b' option specifies a board to build for, in this case the particle_boron, followed by the path to source. cd ~/csse4011/zephyrproject/zephyr/ west build -p auto -b particle_argon samples/basic/blinky Flash the sample program. Make a sure a 'runner' is connected. You will be given a Segger J-Link device to be used with the Particle Argon. west flash -r jlink Option '-r' specifies to flash using JLink, west is capable of tapping into different runners for flashing your devices, later we will explore how to specify runners in the CMakeLists file. If flashing fails, a runner may need to be installed. When using a Segger J-Link Device. Download and install the following JLink Software . Under 'J-Link Software and Documentation Pack', download the 'Linux - 64-bit DEB Installer'. Run the installer and install JLink software. Installation can be verified by running the following command from a terminal JLinkExe exit Additional information for setting up other runners can be found here","title":"5.0 Build a Sample Program (Blinky)"},{"location":"OS/OS.1-Getting_Started/#60-setting-zephyr-base","text":"Setting $ZEPHYR_BASE allows you to invoke west from outside the source directory to build your applications. So we will add this environment to be set at login by bashrc . If you are using a different shell fish or zsh , make sure you set this within those config files. If you installed Zephyr elsewhere, adjust the following accordingly . echo \"# Add Zephyr Base Location to Path export ZEPHYR_BASE=~/csse4011/zephyrproject/zephyr\" >> ~/.bashrc source ~/.bashrc","title":"6.0 Setting Zephyr Base"},{"location":"OS/OS.2-First_Program/","text":"CSSE4011: Tute 2 - First Program 1.0 Motivation The following tutorial will focus on developing your own very first Zephyr application. This involves, setting up an appropriate directory structure and necessary configuration files. 1.1 Hardware Required Segger JLink EDU Mini Particle Argon 2xMicro USB Cables Connection guide: 1. Connect the Particle Argon using the micro-usb cable to your computer 2. Connect JLink ribbon cable to the JTAG header on the Particle Argon, and the opposing end to the J-Link EDU-mini. The lip of the header should be facing away from the edu mini. 3. Connect the JLink edu mini to your computer, and make sure that USB passthrough for this device is enabled in your virtual machine settings. 2.0 Directory Overview A typical Zephyr application is organized in the following format. <home>/apps \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 prj.conf \u2514\u2500\u2500 src \u2514\u2500\u2500 main.c In this course, you will be required to modify and re-use code to implement new features/applications. To allow for this, code that is not specific to an application is placed in a 'myoslib' directory. Where code within 'myoslib' could be drivers for a particular module, for example, an ultrasonic sensor. The structure below is an example representation. . \u251c\u2500\u2500 csse4011_repo/apps/ \u2502 \u251c\u2500\u2500 prac1/ \u2502 \u2502 \u251c\u2500\u2500 CMakeLists.txt \u2502 \u2502 \u251c\u2500\u2500 prj.conf \u2502 \u2502 \u2514\u2500\u2500 src/ \u2502 \u2502 \u2514\u2500\u2500 main.c \u2502 \u2514\u2500\u2500 prac2/ \u2502 \u251c\u2500\u2500 CMakeLists.txt \u2502 \u251c\u2500\u2500 prj.conf \u2502 \u2514\u2500\u2500 src/ \u2502 \u2514\u2500\u2500 main.c | \u2514\u2500\u2500 csse4011_repo/myoslib/ \u251c\u2500\u2500 hal/ \u2502 \u251c\u2500\u2500 status_leds/ \u2502 \u2502 \u251c\u2500\u2500 hal_status_leds.c \u2502 \u2502 \u2514\u2500\u2500 hal_status_leds.h \u2502 \u2514\u2500\u2500 ultrasonic/ \u2502 \u251c\u2500\u2500 hal_ultrasonic.c \u2502 \u2514\u2500\u2500 hal_ultrasonic.h \u2514\u2500\u2500 cli/ \u251c\u2500\u2500 cli_kernel_time_cmd.c \u2514\u2500\u2500 cli_status_leds_cmd.c 3.0 Making A Zephyr Application Within the 'csse4011_repo', make the following modifications to setup a sample directory cd ~/csse4011/csse4011_repo/ mkdir -p apps/sample For the purposes of this tutorial, we will use the existing blinky sample provided in the Zephyr source code. Start by navigating to the Zephyr source we attained in Tute 1. cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky Copy blinky files into our sample application directory, then navigate to sample directory. cp -R * ~/csse4011/csse4011_repo/apps/sample/ cd ~/csse4011/csse4011_repo/apps/sample/ Verify that the following exist within your sample dir . \u2514\u2500\u2500 csse4011/csse4011_repo/apps/ \u2514\u2500\u2500 sample/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 prj.conf \u251c\u2500\u2500 README.rst \u251c\u2500\u2500 sample.yaml \u2514\u2500\u2500 src/ \u2514\u2500\u2500 main.c Add ZEPHYR_BASE to path (Lets you build from outside the Zephyr Source Dir). Append the following line to the end of 'bashrc' (If you haven't already from OS.1 ). For text editing you can use nano instead of vim as it is usually installed by default. To install vim. sudo apt install vim vim ~/.bashrc or use any text editor #Add Zephyr Base to PATH export ZEPHYR_BASE=~/csse4011/zephyrproject/zephyr save and exit. Read and execute bashrc (Loads ZEPHYR_BASE for current shell instance) source ~/.bashrc echo $ZEPHYR_BASE Should now display the path to zephyr base. Build the sample application within our directory cd ~/csse4011/csse4011_repo/apps/sample/ west build -p auto -b particle_argon Flash and Verify that Blinky works. west flash -r jlink The option '-r' lets you specify a runner, in this case we are using JLink to flash the Particle Argon. Make sure that the cables are connected properly. If flashing fails, refer to the end of OS.1-Getting Started and follow instructions for installing runners / additional runners. 4.0 Sample A sample of this is located within tute_solutions/blinky_tute/","title":"2.0 First Program"},{"location":"OS/OS.2-First_Program/#csse4011-tute-2-first-program","text":"","title":"CSSE4011: Tute 2 - First Program"},{"location":"OS/OS.2-First_Program/#10-motivation","text":"The following tutorial will focus on developing your own very first Zephyr application. This involves, setting up an appropriate directory structure and necessary configuration files.","title":"1.0 Motivation"},{"location":"OS/OS.2-First_Program/#11-hardware-required","text":"Segger JLink EDU Mini Particle Argon 2xMicro USB Cables Connection guide: 1. Connect the Particle Argon using the micro-usb cable to your computer 2. Connect JLink ribbon cable to the JTAG header on the Particle Argon, and the opposing end to the J-Link EDU-mini. The lip of the header should be facing away from the edu mini. 3. Connect the JLink edu mini to your computer, and make sure that USB passthrough for this device is enabled in your virtual machine settings.","title":"1.1 Hardware Required"},{"location":"OS/OS.2-First_Program/#20-directory-overview","text":"A typical Zephyr application is organized in the following format. <home>/apps \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 prj.conf \u2514\u2500\u2500 src \u2514\u2500\u2500 main.c In this course, you will be required to modify and re-use code to implement new features/applications. To allow for this, code that is not specific to an application is placed in a 'myoslib' directory. Where code within 'myoslib' could be drivers for a particular module, for example, an ultrasonic sensor. The structure below is an example representation. . \u251c\u2500\u2500 csse4011_repo/apps/ \u2502 \u251c\u2500\u2500 prac1/ \u2502 \u2502 \u251c\u2500\u2500 CMakeLists.txt \u2502 \u2502 \u251c\u2500\u2500 prj.conf \u2502 \u2502 \u2514\u2500\u2500 src/ \u2502 \u2502 \u2514\u2500\u2500 main.c \u2502 \u2514\u2500\u2500 prac2/ \u2502 \u251c\u2500\u2500 CMakeLists.txt \u2502 \u251c\u2500\u2500 prj.conf \u2502 \u2514\u2500\u2500 src/ \u2502 \u2514\u2500\u2500 main.c | \u2514\u2500\u2500 csse4011_repo/myoslib/ \u251c\u2500\u2500 hal/ \u2502 \u251c\u2500\u2500 status_leds/ \u2502 \u2502 \u251c\u2500\u2500 hal_status_leds.c \u2502 \u2502 \u2514\u2500\u2500 hal_status_leds.h \u2502 \u2514\u2500\u2500 ultrasonic/ \u2502 \u251c\u2500\u2500 hal_ultrasonic.c \u2502 \u2514\u2500\u2500 hal_ultrasonic.h \u2514\u2500\u2500 cli/ \u251c\u2500\u2500 cli_kernel_time_cmd.c \u2514\u2500\u2500 cli_status_leds_cmd.c","title":"2.0 Directory Overview"},{"location":"OS/OS.2-First_Program/#30-making-a-zephyr-application","text":"Within the 'csse4011_repo', make the following modifications to setup a sample directory cd ~/csse4011/csse4011_repo/ mkdir -p apps/sample For the purposes of this tutorial, we will use the existing blinky sample provided in the Zephyr source code. Start by navigating to the Zephyr source we attained in Tute 1. cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky Copy blinky files into our sample application directory, then navigate to sample directory. cp -R * ~/csse4011/csse4011_repo/apps/sample/ cd ~/csse4011/csse4011_repo/apps/sample/ Verify that the following exist within your sample dir . \u2514\u2500\u2500 csse4011/csse4011_repo/apps/ \u2514\u2500\u2500 sample/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 prj.conf \u251c\u2500\u2500 README.rst \u251c\u2500\u2500 sample.yaml \u2514\u2500\u2500 src/ \u2514\u2500\u2500 main.c Add ZEPHYR_BASE to path (Lets you build from outside the Zephyr Source Dir). Append the following line to the end of 'bashrc' (If you haven't already from OS.1 ). For text editing you can use nano instead of vim as it is usually installed by default. To install vim. sudo apt install vim vim ~/.bashrc or use any text editor #Add Zephyr Base to PATH export ZEPHYR_BASE=~/csse4011/zephyrproject/zephyr save and exit. Read and execute bashrc (Loads ZEPHYR_BASE for current shell instance) source ~/.bashrc echo $ZEPHYR_BASE Should now display the path to zephyr base. Build the sample application within our directory cd ~/csse4011/csse4011_repo/apps/sample/ west build -p auto -b particle_argon Flash and Verify that Blinky works. west flash -r jlink The option '-r' lets you specify a runner, in this case we are using JLink to flash the Particle Argon. Make sure that the cables are connected properly. If flashing fails, refer to the end of OS.1-Getting Started and follow instructions for installing runners / additional runners.","title":"3.0 Making A Zephyr Application"},{"location":"OS/OS.2-First_Program/#40-sample","text":"A sample of this is located within tute_solutions/blinky_tute/","title":"4.0 Sample"},{"location":"OS/OS.2.1-Building_Tips/","text":"CSSE4011: Tute 2.2 - Application Building Tips 1.0 Motivation This tutorial will focus on modifications to the CMakeLists file to streamline the application development process. 2.0 Setting Build Options Note that these should be added to the top of the CMakeLists file. Additionally, there are other ways to include config files and devicetree overlays. Refer to a application development and device tree guides for more. 2.1 Boards A board to develop can be specified within the top level CMakeLists file as below, the particular name for the board can be found under Zephyr Supported Boards -> boardname or here . set(BOARD board_name) set(BOARD particle_argon) With this set, west build can now omit the '-b board_name' option. By just using west build an application can be created for the particle_argon. 2.2 Runners The flash runner for the board can be set using the below, within the CMakeLists file. set(BOARD_FLASH_RUNNER runner) set(BOARD_FLASH_RUNNER jlink) This allows for west flash to be ran with about specifying the '-r runner' when invoked. west flash 2.3 Config Files Config option files (ending with .conf), can be added to the CMakeLists file using, set(CONF_FILE files.conf) set(CONF_FILE general_config.conf usb_config.conf uart_shell_config.conf) 2.4 Devicetree overlays Devicetree overlay files can be added to the build system using, set(DTC_OVERLAY_FILE overlay.dtsi) set(DTC_OVERLAY_FILE dts/spi3.dtsi)","title":"2.1 Building Tips"},{"location":"OS/OS.2.1-Building_Tips/#csse4011-tute-22-application-building-tips","text":"","title":"CSSE4011: Tute 2.2 - Application Building Tips"},{"location":"OS/OS.2.1-Building_Tips/#10-motivation","text":"This tutorial will focus on modifications to the CMakeLists file to streamline the application development process.","title":"1.0 Motivation"},{"location":"OS/OS.2.1-Building_Tips/#20-setting-build-options","text":"Note that these should be added to the top of the CMakeLists file. Additionally, there are other ways to include config files and devicetree overlays. Refer to a application development and device tree guides for more.","title":"2.0 Setting Build Options"},{"location":"OS/OS.2.1-Building_Tips/#21-boards","text":"A board to develop can be specified within the top level CMakeLists file as below, the particular name for the board can be found under Zephyr Supported Boards -> boardname or here . set(BOARD board_name) set(BOARD particle_argon) With this set, west build can now omit the '-b board_name' option. By just using west build an application can be created for the particle_argon.","title":"2.1 Boards"},{"location":"OS/OS.2.1-Building_Tips/#22-runners","text":"The flash runner for the board can be set using the below, within the CMakeLists file. set(BOARD_FLASH_RUNNER runner) set(BOARD_FLASH_RUNNER jlink) This allows for west flash to be ran with about specifying the '-r runner' when invoked. west flash","title":"2.2 Runners"},{"location":"OS/OS.2.1-Building_Tips/#23-config-files","text":"Config option files (ending with .conf), can be added to the CMakeLists file using, set(CONF_FILE files.conf) set(CONF_FILE general_config.conf usb_config.conf uart_shell_config.conf)","title":"2.3 Config Files"},{"location":"OS/OS.2.1-Building_Tips/#24-devicetree-overlays","text":"Devicetree overlay files can be added to the build system using, set(DTC_OVERLAY_FILE overlay.dtsi) set(DTC_OVERLAY_FILE dts/spi3.dtsi)","title":"2.4 Devicetree overlays"},{"location":"OS/OS.2.2-Implementing_Libraries/","text":"CSSE4011: Tute 2.2 - Implementing a Simple Library 1.0 Motivation The following tutorial looks at implementing a simple library and adding library files to the build system. 2.0 Implementing A Basic Library 2.1 Including library files We will build on the blinky sample that was created in OS.2-First_Program . We will start by creating a library file to implement functions that will: Initialize GPIO for led Provide a wrapper functions for turning led on and off. The following directory structure will be implemented for this basic library application. Where, blinky_tute_ext is a copy of the application made in OS.2-First_Program . . \u251c\u2500\u2500 blinky_tute \u2502 \u251c\u2500\u2500 CMakeLists.txt \u2502 \u251c\u2500\u2500 prj.conf \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main.c \u251c\u2500\u2500 blinky_tute_ext \u2502 \u251c\u2500\u2500 CMakeLists.txt \u2502 \u251c\u2500\u2500 prj.conf \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main.c \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 led_driver \u2502 \u251c\u2500\u2500 led_driver.c \u2502 \u2514\u2500\u2500 led_driver.h 2.2 Library Files In this example, the library files are in lib/led_driver/ , where: led_driver.c - provides simple led wrapper functions to demonstrate a library implementation. led_driver.h - provides the respective header file to be included by any shared targets. 2.2.1 Creating a library source file (led_driver.c) First include necessary Zephyr headers files required by the application, in this case, for an led to toggle, we use. #include <zephyr.h> #include <device.h> #include <devicetree.h> #include <drivers/gpio.h> /* Local Library Include */ #include \"led_driver.h\" This can be followed by any source code required to implement the application/driver logic. 2.2.2 Creating a library header file (led_driver.h) The header file can be made as per usual using typical syntax. There are no particular restrictions on the way this is implemented. #ifdef LED_DRIVER_H #define LED_DRIVER_H /* Device Tree Macros */ #define LED0_NODE DT_ALIAS(led0) /* Function Prototypes..*/ int led0_init ( void ); #endif 2.3 Adding Sources and Header files to CMakeLists With this, you can now created a basic library to implement re-usable code. However, to add this to the build system of this intended application. You must add these files to the CMakeLists file of the target application. In this case the following file blinky_tute_ext/CMakeLists.txt Append the following to the CMakeLists.txt file #Add Include Directories include_directories ( ../lib/led_driver/ ) #Add Target Sources target_sources ( app PRIVATE src/main.c ../lib/led_driver/led_driver.c ) Note: That relative paths are interpreted as relative to the current source directory. Note: That include_directories(x/y) applies the include directories to all targets, if you want to specify which targets use with includes, use target_include_directories(t x/y) , see here CMakeLists documentation states that: The include directories are added to the directory property INCLUDE_DIRECTORIES for the current CMakeLists file. They are also added to the target property INCLUDE_DIRECTORIES for each target in the current CMakeLists file. The target property values are the ones used by the generators. You can also use a seperate CMakeLists files to compile your libraries using a hierarchical cmake build system if desired. Refer to cmake build system documentation for more. 2.4 Using Library Code in Target Application Finally, we can now use the library code within our target application. To do this, include the respective header files. In this case, include the following in src/main.c /* Include file from our library */ #include \"led_driver.h\" Now you can call the library functions as desired. 3.0 Tutorial Question Using the above, extend the blinky program by implementing simple wrapper functions to: Init led gpio pin Power on/off led0 pin Deinit led gpio pin Refer to the Zephyr GPIO API 4.0 Sample Solution A sample solution is uploaded in the docs repository. Find located within, tute_solutions/blinky_tute_ext/src/ tute_solutions/lib/led_driver/ This code can be built with: west build -p -b <board_name> and flashed with west flash -r 'runner' Refer to the board flashing tutorials for additional build/flash guides.","title":"2.2 Implementing Libraries"},{"location":"OS/OS.2.2-Implementing_Libraries/#csse4011-tute-22-implementing-a-simple-library","text":"","title":"CSSE4011: Tute 2.2 - Implementing a Simple Library"},{"location":"OS/OS.2.2-Implementing_Libraries/#10-motivation","text":"The following tutorial looks at implementing a simple library and adding library files to the build system.","title":"1.0 Motivation"},{"location":"OS/OS.2.2-Implementing_Libraries/#20-implementing-a-basic-library","text":"","title":"2.0 Implementing A Basic Library"},{"location":"OS/OS.2.2-Implementing_Libraries/#21-including-library-files","text":"We will build on the blinky sample that was created in OS.2-First_Program . We will start by creating a library file to implement functions that will: Initialize GPIO for led Provide a wrapper functions for turning led on and off. The following directory structure will be implemented for this basic library application. Where, blinky_tute_ext is a copy of the application made in OS.2-First_Program . . \u251c\u2500\u2500 blinky_tute \u2502 \u251c\u2500\u2500 CMakeLists.txt \u2502 \u251c\u2500\u2500 prj.conf \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main.c \u251c\u2500\u2500 blinky_tute_ext \u2502 \u251c\u2500\u2500 CMakeLists.txt \u2502 \u251c\u2500\u2500 prj.conf \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main.c \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 led_driver \u2502 \u251c\u2500\u2500 led_driver.c \u2502 \u2514\u2500\u2500 led_driver.h","title":"2.1 Including library files"},{"location":"OS/OS.2.2-Implementing_Libraries/#22-library-files","text":"In this example, the library files are in lib/led_driver/ , where: led_driver.c - provides simple led wrapper functions to demonstrate a library implementation. led_driver.h - provides the respective header file to be included by any shared targets.","title":"2.2 Library Files"},{"location":"OS/OS.2.2-Implementing_Libraries/#221-creating-a-library-source-file-led_driverc","text":"First include necessary Zephyr headers files required by the application, in this case, for an led to toggle, we use. #include <zephyr.h> #include <device.h> #include <devicetree.h> #include <drivers/gpio.h> /* Local Library Include */ #include \"led_driver.h\" This can be followed by any source code required to implement the application/driver logic.","title":"2.2.1 Creating a library source file (led_driver.c)"},{"location":"OS/OS.2.2-Implementing_Libraries/#222-creating-a-library-header-file-led_driverh","text":"The header file can be made as per usual using typical syntax. There are no particular restrictions on the way this is implemented. #ifdef LED_DRIVER_H #define LED_DRIVER_H /* Device Tree Macros */ #define LED0_NODE DT_ALIAS(led0) /* Function Prototypes..*/ int led0_init ( void ); #endif","title":"2.2.2 Creating a library header file (led_driver.h)"},{"location":"OS/OS.2.2-Implementing_Libraries/#23-adding-sources-and-header-files-to-cmakelists","text":"With this, you can now created a basic library to implement re-usable code. However, to add this to the build system of this intended application. You must add these files to the CMakeLists file of the target application. In this case the following file blinky_tute_ext/CMakeLists.txt Append the following to the CMakeLists.txt file #Add Include Directories include_directories ( ../lib/led_driver/ ) #Add Target Sources target_sources ( app PRIVATE src/main.c ../lib/led_driver/led_driver.c ) Note: That relative paths are interpreted as relative to the current source directory. Note: That include_directories(x/y) applies the include directories to all targets, if you want to specify which targets use with includes, use target_include_directories(t x/y) , see here CMakeLists documentation states that: The include directories are added to the directory property INCLUDE_DIRECTORIES for the current CMakeLists file. They are also added to the target property INCLUDE_DIRECTORIES for each target in the current CMakeLists file. The target property values are the ones used by the generators. You can also use a seperate CMakeLists files to compile your libraries using a hierarchical cmake build system if desired. Refer to cmake build system documentation for more.","title":"2.3 Adding Sources and Header files to CMakeLists"},{"location":"OS/OS.2.2-Implementing_Libraries/#24-using-library-code-in-target-application","text":"Finally, we can now use the library code within our target application. To do this, include the respective header files. In this case, include the following in src/main.c /* Include file from our library */ #include \"led_driver.h\" Now you can call the library functions as desired.","title":"2.4 Using Library Code in Target Application"},{"location":"OS/OS.2.2-Implementing_Libraries/#30-tutorial-question","text":"Using the above, extend the blinky program by implementing simple wrapper functions to: Init led gpio pin Power on/off led0 pin Deinit led gpio pin Refer to the Zephyr GPIO API","title":"3.0 Tutorial Question"},{"location":"OS/OS.2.2-Implementing_Libraries/#40-sample-solution","text":"A sample solution is uploaded in the docs repository. Find located within, tute_solutions/blinky_tute_ext/src/ tute_solutions/lib/led_driver/ This code can be built with: west build -p -b <board_name> and flashed with west flash -r 'runner' Refer to the board flashing tutorials for additional build/flash guides.","title":"4.0 Sample Solution"},{"location":"OS/OS.4-Threading/","text":"CSSE4011: Tute 4 - Threading in Zephyr 1.0 Motivation In this tutorial, we focus on learning the use of threads in Zephyr RTOS. The use of threads is to implement an application that can 'multi-task'. 1.1 Summary of threads Threads are typically created with an appropriate level of priority based on their task within the application, and also an appropriate stack size. When a thread is interrupted and switched out for another thread (code context changed), this is know as a context switch. Typically, based on thread synchronization implementation/priorities, the kernel will perform a context switch between threads, allowing for other threads to perform their duties. On a micro-controller unit (MCU), this mimics 'multi-tasking' within a program. Example, in an IoT based application, where an application may need to maintain a network, communicate and collect data from hardware sensors, maintain a device power profile. Threads allow an application to maintain multiple 'threads' of execution with different contexts. 2.0 Threads in Zephyr In Zephyr [1], a thread is a kernel object that is used for application processing that is too lengthy or too complex to be performed by an interrupt service routine (ISR). Any number of threads can be defined by an application (limited only by available RAM). Each thread is referenced by a thread id that is assigned when the thread is spawned. Additionally, each thread is allocated a specific priority and a stack size at creation (see here for more details). 2.1 Using threads in Zephyr RTOS There are two ways in which a threads can be created in Zephyr, compile-time and at run-time. An application that has fixed functionality, can be solely implemented with compile-time threads. When compile-time thread is defined, it starts immediately as the program begins. Note, that there is not inherent diffrence between compile-time and run-time threads, other than the way in which they are created. If an application requires a thread to be created at run-time, a run-time thread can be created, this process is similar to how threads are created in freeRTOS. 2.2 Thread Creation in Zephyr RTOS NOTE: It is strongly recommended that you read the Zephyr thread API , as it shows you the intricate details and correct usage of the API for additional features. 2.2.1 Compile-Time Threads A compile-time thread in Zephyr is created by the following macro. K_THREAD_DEFINE(name, stack_size, entry, p1, p2, p3, prio, options, delay) The below snippet shows how a compile-time thread can be setup. Refer to Zephyr Thread API for more details. #define MY_STACK_SIZE 500 #define MY_PRIORITY 5 void my_entry_point ( void * , void * , void * ); K_THREAD_DEFINE ( my_tid , MY_STACK_SIZE , my_entry_point , NULL , NULL , NULL , MY_PRIORITY , 0 , 0 ); /* A thread, that does some work */ void my_entry_point ( void * a , void * b , void * c ) { while ( 1 ) { /* * do some work */ k_msleep ( 1000 ); } } 2.2.2 Run-Time Threads Run-time threads in Zephyr can be created as seen below. This code performs the same fundamental actions as compile-time thread. However, it is created at run-time. #define MY_STACK_SIZE 500 #define MY_PRIORITY 5 void my_entry_point ( void * , void * , void * ); K_THREAD_STACK_DEFINE ( my_stack_area , MY_STACK_SIZE ); struct k_thread my_thread_data ; /* Application entry point */ int main ( void ) { /* Spawn new thread at run-time */ k_tid_t my_tid = k_thread_create ( & my_thread_data , my_stack_area , K_THREAD_STACK_SIZEOF ( my_stack_area ), my_entry_point , NULL , NULL , NULL , MY_PRIORITY , 0 , K_NO_WAIT ); return 0 ; } /* A thread, that does some work */ void my_entry_point ( void * a , void * b , void * c ) { while ( 1 ) { /* * do some work */ k_msleep ( 1000 ); } } 2.2.3 Thread Priorities In Zephyr RTOS, a thread\u2019s priority is an integer value, and can be either negative or non-negative. Numerically lower priorities takes precedence over numerically higher values. For example, the scheduler gives thread A of priority 4 higher priority over thread B of priority 7; likewise thread C of priority -2 has higher priority than both thread A and thread B see here . Priorities for threads should be chosen carefully based on the application. You may notice issues with thread starvation (not getting enough time to run), if priorities are chosen inappropriately. A threads priority can also be changed after it has been created. 2.2.4 Thread Scheduling The kernel\u2019s priority-based scheduler allows an application\u2019s thread to share the CPU. There are two different 'types' of threads in Zephyr with respect to the scheduler. These are 'Pre-emptive' and 'Cooperative' threads. In summary, once a cooperative thread becomes the current thread, it remains the current thread until it performs an action that makes it unready. Whereas, a preemptive thread becomes the current thread, it remains the current thread until a higher priority thread becomes ready, or until the thread performs an action that makes it unready see here . A cooperative thread has a negative priority value. A preemptible thread has a non-negative priority value. In application as per , Use cooperative threads for device drivers and other performance-critical work. Use cooperative threads to implement mutually exclusion without the need for a kernel object, such as a mutex. Use preemptive threads to give priority to time-sensitive processing over less time-sensitive processing. 3.0 Tutorial Question: Copy the zephyr/sample/blinky program to a working application directory, then, implement two threads, where one thread will turn on the led, and the other thread will turn off the led. Use either the thingy52 or the Arduino Sense to test your code. Question: What is wrong with an implementation like this? Why is this not ideal, what type of issues might you run into? 3.1 Sample Solution A sample solution is uploaded in the docs repository. Find located within, tute_solutions/OS4_tute/src/ This code can be built with: west build -p -b <board_name> and flashed with west flash -r 'runner' Refer to the board flashing tutorials for additional build/flash guides.","title":"4.0 Threading"},{"location":"OS/OS.4-Threading/#csse4011-tute-4-threading-in-zephyr","text":"","title":"CSSE4011: Tute 4 - Threading in Zephyr"},{"location":"OS/OS.4-Threading/#10-motivation","text":"In this tutorial, we focus on learning the use of threads in Zephyr RTOS. The use of threads is to implement an application that can 'multi-task'.","title":"1.0 Motivation"},{"location":"OS/OS.4-Threading/#11-summary-of-threads","text":"Threads are typically created with an appropriate level of priority based on their task within the application, and also an appropriate stack size. When a thread is interrupted and switched out for another thread (code context changed), this is know as a context switch. Typically, based on thread synchronization implementation/priorities, the kernel will perform a context switch between threads, allowing for other threads to perform their duties. On a micro-controller unit (MCU), this mimics 'multi-tasking' within a program. Example, in an IoT based application, where an application may need to maintain a network, communicate and collect data from hardware sensors, maintain a device power profile. Threads allow an application to maintain multiple 'threads' of execution with different contexts.","title":"1.1 Summary of threads"},{"location":"OS/OS.4-Threading/#20-threads-in-zephyr","text":"In Zephyr [1], a thread is a kernel object that is used for application processing that is too lengthy or too complex to be performed by an interrupt service routine (ISR). Any number of threads can be defined by an application (limited only by available RAM). Each thread is referenced by a thread id that is assigned when the thread is spawned. Additionally, each thread is allocated a specific priority and a stack size at creation (see here for more details).","title":"2.0 Threads in Zephyr"},{"location":"OS/OS.4-Threading/#21-using-threads-in-zephyr-rtos","text":"There are two ways in which a threads can be created in Zephyr, compile-time and at run-time. An application that has fixed functionality, can be solely implemented with compile-time threads. When compile-time thread is defined, it starts immediately as the program begins. Note, that there is not inherent diffrence between compile-time and run-time threads, other than the way in which they are created. If an application requires a thread to be created at run-time, a run-time thread can be created, this process is similar to how threads are created in freeRTOS.","title":"2.1 Using threads in Zephyr RTOS"},{"location":"OS/OS.4-Threading/#22-thread-creation-in-zephyr-rtos","text":"NOTE: It is strongly recommended that you read the Zephyr thread API , as it shows you the intricate details and correct usage of the API for additional features.","title":"2.2 Thread Creation in Zephyr RTOS"},{"location":"OS/OS.4-Threading/#221-compile-time-threads","text":"A compile-time thread in Zephyr is created by the following macro. K_THREAD_DEFINE(name, stack_size, entry, p1, p2, p3, prio, options, delay) The below snippet shows how a compile-time thread can be setup. Refer to Zephyr Thread API for more details. #define MY_STACK_SIZE 500 #define MY_PRIORITY 5 void my_entry_point ( void * , void * , void * ); K_THREAD_DEFINE ( my_tid , MY_STACK_SIZE , my_entry_point , NULL , NULL , NULL , MY_PRIORITY , 0 , 0 ); /* A thread, that does some work */ void my_entry_point ( void * a , void * b , void * c ) { while ( 1 ) { /* * do some work */ k_msleep ( 1000 ); } }","title":"2.2.1 Compile-Time Threads"},{"location":"OS/OS.4-Threading/#222-run-time-threads","text":"Run-time threads in Zephyr can be created as seen below. This code performs the same fundamental actions as compile-time thread. However, it is created at run-time. #define MY_STACK_SIZE 500 #define MY_PRIORITY 5 void my_entry_point ( void * , void * , void * ); K_THREAD_STACK_DEFINE ( my_stack_area , MY_STACK_SIZE ); struct k_thread my_thread_data ; /* Application entry point */ int main ( void ) { /* Spawn new thread at run-time */ k_tid_t my_tid = k_thread_create ( & my_thread_data , my_stack_area , K_THREAD_STACK_SIZEOF ( my_stack_area ), my_entry_point , NULL , NULL , NULL , MY_PRIORITY , 0 , K_NO_WAIT ); return 0 ; } /* A thread, that does some work */ void my_entry_point ( void * a , void * b , void * c ) { while ( 1 ) { /* * do some work */ k_msleep ( 1000 ); } }","title":"2.2.2 Run-Time Threads"},{"location":"OS/OS.4-Threading/#223-thread-priorities","text":"In Zephyr RTOS, a thread\u2019s priority is an integer value, and can be either negative or non-negative. Numerically lower priorities takes precedence over numerically higher values. For example, the scheduler gives thread A of priority 4 higher priority over thread B of priority 7; likewise thread C of priority -2 has higher priority than both thread A and thread B see here . Priorities for threads should be chosen carefully based on the application. You may notice issues with thread starvation (not getting enough time to run), if priorities are chosen inappropriately. A threads priority can also be changed after it has been created.","title":"2.2.3 Thread Priorities"},{"location":"OS/OS.4-Threading/#224-thread-scheduling","text":"The kernel\u2019s priority-based scheduler allows an application\u2019s thread to share the CPU. There are two different 'types' of threads in Zephyr with respect to the scheduler. These are 'Pre-emptive' and 'Cooperative' threads. In summary, once a cooperative thread becomes the current thread, it remains the current thread until it performs an action that makes it unready. Whereas, a preemptive thread becomes the current thread, it remains the current thread until a higher priority thread becomes ready, or until the thread performs an action that makes it unready see here . A cooperative thread has a negative priority value. A preemptible thread has a non-negative priority value. In application as per , Use cooperative threads for device drivers and other performance-critical work. Use cooperative threads to implement mutually exclusion without the need for a kernel object, such as a mutex. Use preemptive threads to give priority to time-sensitive processing over less time-sensitive processing.","title":"2.2.4 Thread Scheduling"},{"location":"OS/OS.4-Threading/#30-tutorial-question","text":"Copy the zephyr/sample/blinky program to a working application directory, then, implement two threads, where one thread will turn on the led, and the other thread will turn off the led. Use either the thingy52 or the Arduino Sense to test your code. Question: What is wrong with an implementation like this? Why is this not ideal, what type of issues might you run into?","title":"3.0 Tutorial Question:"},{"location":"OS/OS.4-Threading/#31-sample-solution","text":"A sample solution is uploaded in the docs repository. Find located within, tute_solutions/OS4_tute/src/ This code can be built with: west build -p -b <board_name> and flashed with west flash -r 'runner' Refer to the board flashing tutorials for additional build/flash guides.","title":"3.1 Sample Solution"},{"location":"OS/OS.5.1-Thread_Sync/","text":"CSSE4011: Tute 5.1 - Thread Synchronization 1.0 Motivation In the previous tutorial, basic thread creation and usage was covered. In this tutorial, we aim to cover thread synchronization. 1.1 Thread Synchronization Summary Thead synchronization is typically used for sharing of resources without interference (mutual exclusion) and for coordinating the thread functionality and interactions within the operating system. For example, think of a resource where multiple threads write to a shared resource. It is important to ensure that only one writer is currently writing to the resource, to avoid interference and data corruption. In such a case, synchronization must be used between the writer threads to ensure intended functionality. Additionally, the application could use coordination between reader and writer threads, so that readers only read when data is ready. In an embedded environment, an application might want to enforce that only one thread is accessing hardware (senors etc..) at a time, or to indicate that a particular hardware resource is ready to use. In such a case, synchronization must be used. 2.0 Thread Synchronization and Communication in Zephyr 2.1 Thread Synchronization in Zephyr Zephyr offers multiple synchronization primitives, such as: Semaphores Mutexs Condition Variables Refer to the API guides (links section) for detailed information on implementing each of the above. In this tute, we will explore using semaphores to synchronize the blinky thread created in OS.4-Threading . 2.2 Semaphore Implementation Within Zephyr, a semaphore can be defined by the use of the following macro K_SEM_DEFINE ( sem_name , 0 , 1 ); or, using the function k_sem_init() struct k_sem sem_name ; void main ( void ) { k_sem_init ( & sem_name , 0 , 1 ); } The typical application of a semaphore can be as seen below: void interrupt_handler ( void * arg ) { /* Interrupt indicative of some data ready */ k_sem_give ( & data_ready_sem ); } void consumer_thread ( void ) { while ( 1 ) { if ( k_sem_take ( & data_ready_sem , K_MSEC ( 850 ) != 0 )) { /* * Data not received within expected timeout of 850ms, * fallback subroutine... */ continue ; } /* Semaphore was attained within time out */ /* Read the data, and do some work... */ k_msleep ( 500 ); } } The example above, shows a scenario where a semaphore is used to signal by an interrupt handler that some data is ready. Similarly, semaphores can be used between multiple threads for coordination and signaling. Refer to here , for additional implementation information. 2.3 Mutex in Zephyr A mutex in Zephyr RTOS is a kernel object that implements the traditional functionality of a mutex. A mutex can allow multiple threads to safely access and share hardware or software resources as per . Where a semaphore may allow finite access (i.e counting semaphore) to a resource, mutexs only allow a thread to access one resource at a time (a locking mechanism). The mutex implementation api within Zephyr is functionally similar to that of the semaphore api outlined in section 2.2 . See here for Zephyr mutex api guide. 2.4 Condition Variables in Zephyr Zephyr allows for 'Condition Variables' to be used as a synchronization primitive, where, threads can wait on until a particular condition has occurred. Waiting threads will be in a queue when a particular state of execution is not desired (by waiting on the condition). Zephyr Condition Variable API shows the following example to be a typical conditional variable implementation with two threads. In the main thread, K_MUTEX_DEFINE ( mutex ); K_CONDVAR_DEFINE ( condvar ) void main ( void ) { k_mutex_lock ( & mutex , K_FOREVER ); /* block this thread until another thread signals cond. While * blocked, the mutex is released, then re-acquired before this * thread is woken up and the call returns. */ k_condvar_wait ( & condvar , & mutex , K_FOREVER ); ... k_mutex_unlock ( & mutex ); } and in the worker thread, void worker_thread ( void ) { k_mutex_lock ( & mutex , K_FOREVER ); /* * Do some work and fulfill the condition */ ... ... k_condvar_signal ( & condvar ); k_mutex_unlock ( & mutex ); } 2.4.1 Condition Variable Typical Use Condition variables should be used with a mutex to signal changing conditions/states from one thread to another. Condition variables are not events in that they are not the condition itself. Refer to the implementation API for more details. 3.0 Tutorial Question 1. Use two semaphores to enforce synchronization between the two blinky threads created in tute OS.4-Threading. The implementation should only use delays to indicate that the led visibly blinks. 3.1 Sample Solution A sample solution is uploaded in the docs repository. Find located within, tute_solutions/OS-5.1_tute/src/ This code can be built with: west build -p -b <board_name> and flashed with west flash -r 'runner' Refer to the board flashing tutorials for additional build/flash guides.","title":"5.1 Thread Synchronization"},{"location":"OS/OS.5.1-Thread_Sync/#csse4011-tute-51-thread-synchronization","text":"","title":"CSSE4011: Tute 5.1 - Thread Synchronization"},{"location":"OS/OS.5.1-Thread_Sync/#10-motivation","text":"In the previous tutorial, basic thread creation and usage was covered. In this tutorial, we aim to cover thread synchronization.","title":"1.0 Motivation"},{"location":"OS/OS.5.1-Thread_Sync/#11-thread-synchronization-summary","text":"Thead synchronization is typically used for sharing of resources without interference (mutual exclusion) and for coordinating the thread functionality and interactions within the operating system. For example, think of a resource where multiple threads write to a shared resource. It is important to ensure that only one writer is currently writing to the resource, to avoid interference and data corruption. In such a case, synchronization must be used between the writer threads to ensure intended functionality. Additionally, the application could use coordination between reader and writer threads, so that readers only read when data is ready. In an embedded environment, an application might want to enforce that only one thread is accessing hardware (senors etc..) at a time, or to indicate that a particular hardware resource is ready to use. In such a case, synchronization must be used.","title":"1.1 Thread Synchronization Summary"},{"location":"OS/OS.5.1-Thread_Sync/#20-thread-synchronization-and-communication-in-zephyr","text":"","title":"2.0 Thread Synchronization and Communication in Zephyr"},{"location":"OS/OS.5.1-Thread_Sync/#21-thread-synchronization-in-zephyr","text":"Zephyr offers multiple synchronization primitives, such as: Semaphores Mutexs Condition Variables Refer to the API guides (links section) for detailed information on implementing each of the above. In this tute, we will explore using semaphores to synchronize the blinky thread created in OS.4-Threading .","title":"2.1 Thread Synchronization in Zephyr"},{"location":"OS/OS.5.1-Thread_Sync/#22-semaphore-implementation","text":"Within Zephyr, a semaphore can be defined by the use of the following macro K_SEM_DEFINE ( sem_name , 0 , 1 ); or, using the function k_sem_init() struct k_sem sem_name ; void main ( void ) { k_sem_init ( & sem_name , 0 , 1 ); } The typical application of a semaphore can be as seen below: void interrupt_handler ( void * arg ) { /* Interrupt indicative of some data ready */ k_sem_give ( & data_ready_sem ); } void consumer_thread ( void ) { while ( 1 ) { if ( k_sem_take ( & data_ready_sem , K_MSEC ( 850 ) != 0 )) { /* * Data not received within expected timeout of 850ms, * fallback subroutine... */ continue ; } /* Semaphore was attained within time out */ /* Read the data, and do some work... */ k_msleep ( 500 ); } } The example above, shows a scenario where a semaphore is used to signal by an interrupt handler that some data is ready. Similarly, semaphores can be used between multiple threads for coordination and signaling. Refer to here , for additional implementation information.","title":"2.2 Semaphore Implementation"},{"location":"OS/OS.5.1-Thread_Sync/#23-mutex-in-zephyr","text":"A mutex in Zephyr RTOS is a kernel object that implements the traditional functionality of a mutex. A mutex can allow multiple threads to safely access and share hardware or software resources as per . Where a semaphore may allow finite access (i.e counting semaphore) to a resource, mutexs only allow a thread to access one resource at a time (a locking mechanism). The mutex implementation api within Zephyr is functionally similar to that of the semaphore api outlined in section 2.2 . See here for Zephyr mutex api guide.","title":"2.3 Mutex in Zephyr"},{"location":"OS/OS.5.1-Thread_Sync/#24-condition-variables-in-zephyr","text":"Zephyr allows for 'Condition Variables' to be used as a synchronization primitive, where, threads can wait on until a particular condition has occurred. Waiting threads will be in a queue when a particular state of execution is not desired (by waiting on the condition). Zephyr Condition Variable API shows the following example to be a typical conditional variable implementation with two threads. In the main thread, K_MUTEX_DEFINE ( mutex ); K_CONDVAR_DEFINE ( condvar ) void main ( void ) { k_mutex_lock ( & mutex , K_FOREVER ); /* block this thread until another thread signals cond. While * blocked, the mutex is released, then re-acquired before this * thread is woken up and the call returns. */ k_condvar_wait ( & condvar , & mutex , K_FOREVER ); ... k_mutex_unlock ( & mutex ); } and in the worker thread, void worker_thread ( void ) { k_mutex_lock ( & mutex , K_FOREVER ); /* * Do some work and fulfill the condition */ ... ... k_condvar_signal ( & condvar ); k_mutex_unlock ( & mutex ); }","title":"2.4 Condition Variables in Zephyr"},{"location":"OS/OS.5.1-Thread_Sync/#241-condition-variable-typical-use","text":"Condition variables should be used with a mutex to signal changing conditions/states from one thread to another. Condition variables are not events in that they are not the condition itself. Refer to the implementation API for more details.","title":"2.4.1 Condition Variable Typical Use"},{"location":"OS/OS.5.1-Thread_Sync/#30-tutorial-question","text":"1. Use two semaphores to enforce synchronization between the two blinky threads created in tute OS.4-Threading. The implementation should only use delays to indicate that the led visibly blinks.","title":"3.0 Tutorial Question"},{"location":"OS/OS.5.1-Thread_Sync/#31-sample-solution","text":"A sample solution is uploaded in the docs repository. Find located within, tute_solutions/OS-5.1_tute/src/ This code can be built with: west build -p -b <board_name> and flashed with west flash -r 'runner' Refer to the board flashing tutorials for additional build/flash guides.","title":"3.1 Sample Solution"},{"location":"OS/OS.5.2-Thread_Communication/","text":"CSSE4011: Tute 5.2 - Thread Communication 1.0 Motivation The following tutorial aims to introduce inter-thread communication (ITC) and useful communication primitives within Zephyr RTOS. 1.1 Inter-Thread Communication (ITC) Similar to inter-process-communications (IPC) in typical operating systems, ITC allows one thead to share data between another thread(s). Where mutexs and semaphores are typically used for mutual exclusion and signalling, data passing/ITC allows for threads to communicate beyond primitive signaling. 1.2. Prerequisites Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1, BRD.1 and CN.3-Serial_Console or CN.5-Shell (for printk() usage) 2.0 Thread Communication in Zephyr 2.1 Data Passing in Zephyr Zephyr RTOS (as of V2.7.XX) offers a few different options for ITC. To name a few, * First in first out buffers (FIFO) * Last in first out buffer (LIFO) * Stacks * Message queues, Mailboxes and Pipes Some of these are ideal for particular use cases, to determine which ITC protocol might best fit an application, refer to the Data Passing guidelines table . More information on the implementation of each primitive can be found in the api guides (links below the table ). 2.2 General Message Queues In this tutorial, we will focus on implementing a message queues between threads. As they can be typically be used for a wide range of applications, it is a good starting point for learning ITC in Zephyr. The api guide can be found here . What is a message queue? \" A message queue is a kernel object that implements a simple message queue, allowing threads and ISRs to asynchronously send and receive fixed-size data items .\" 2.3 Implementing Message Queues Start by making a basic Zephyr application, you may use a copy of the sample solution provided in CN.4-Shell ( shell_example ) and use this as a boilerplate. The provided solution has USB-Shell and USB-Printk enabled. Start by editing the source file. vim src/main.c The following macro allows for the definition of a message queue in Zephyr, add this to your source file. K_MSGQ_DEFINE ( my_msgq , sizeof ( struct data_packet ), 10 , 4 ); Where, a message queue named my_msgq is initialized, that queues 10 struct data_packet items, where the structure is aligned to an address that is divisible by 4 (4-byte aligned). To make this work, we must also define a struct data_packet globally (before macro usage). struct data_packet { uint16_t preamble ; char string [ 32 ]; }; In our main(), we can add some data to our struct /* MSGQ Packet */ struct data_packet packet ; packet . preamble = 0xAA ; snprintk ( packet . string , sizeof ( packet . string ), \"Colonels Recipe.exe \\n \" ); and lets put this packet on our queue, (add this to the while loop in main()) /* Send Messages to consumers */ if ( k_msgq_put ( & my_msgq , & packet , K_NO_WAIT ) != 0 ) { /* Queue is full, we could purge it, a loop can be * implemented here to keep trying after a purge. */ k_msgq_purge ( & my_msgq ); } Now, we will add another thread (alongside main), so we can test the ITC between two threads using the message queue. Note: Make sure to give this thread sufficient stack size as message queues are passed by copy . /* Define Consumer Thread */ void consumer_thread ( void ); #define STACK_SIZE 1024 #define THREAD_PRIOR 3 #define THREAD_DELAY 0 #define OPTIONS 0 K_THREAD_DEFINE ( consumer_thread_tid , STACK_SIZE , consumer_thread , NULL , NULL , NULL , THREAD_PRIOR , OPTIONS , THREAD_DELAY ); /* * Consumer thread for testing message queue */ void consumer_thread ( void ) { struct data_packet data ; while ( 1 ) { if ( k_msgq_get ( & my_msgq , & data , K_FOREVER ) == 0 ) { if ( data . preamble == 0xAA ) printk ( \"MSG Received: %s \\n \" , data . string ); memset ( & data , 0 , sizeof ( struct data_packet )); } } } 2.4 Testing This application can now be built and flashed using: west build -p auto -b arduino_nano_33_ble west flash --bossac = $HOME /csse4011/BOSSA/BOSSA/bin/bossac #Check the Path is correct As per previous guides on Shell and Console implementation, attach a session to screen. sudo screen /dev/ttyACM0 [00:00:00.005,340] <inf> usb_cdc_acm: Device suspended [00:00:00.165,863] <inf> usb_cdc_acm: Device resumed [00:00:00.432,922] <inf> usb_cdc_acm: Device configured MSG Received: Colonels Recipe.exe MSG Received: Colonels Recipe.exe MSG Received: Colonels Recipe.exe MSG Received: Colonels Recipe.exe MSG Received: Colonels Recipe.exe CSSE4011:~$ 2.5 Additional Notes This tutorial is a guide for implementing basic message queues in Zephyr RTOS, it is strongly suggested that you refer to the Zephyr API guides here and here for additional information. 3.0 Sample Solution A sample solution is provided under, REPO_TOP/tute_soltions/OS-5.2_tute/ this solution implements the above functionality into a Zephyr application. Feel free to use it and modify it.","title":"5.2 Thread Communication"},{"location":"OS/OS.5.2-Thread_Communication/#csse4011-tute-52-thread-communication","text":"","title":"CSSE4011: Tute 5.2 - Thread Communication"},{"location":"OS/OS.5.2-Thread_Communication/#10-motivation","text":"The following tutorial aims to introduce inter-thread communication (ITC) and useful communication primitives within Zephyr RTOS.","title":"1.0 Motivation"},{"location":"OS/OS.5.2-Thread_Communication/#11-inter-thread-communication-itc","text":"Similar to inter-process-communications (IPC) in typical operating systems, ITC allows one thead to share data between another thread(s). Where mutexs and semaphores are typically used for mutual exclusion and signalling, data passing/ITC allows for threads to communicate beyond primitive signaling.","title":"1.1 Inter-Thread Communication (ITC)"},{"location":"OS/OS.5.2-Thread_Communication/#12-prerequisites","text":"Ensure that you have completed/understand the following tutorials. OS.1, OS.2, OS.2.1, BRD.1 and CN.3-Serial_Console or CN.5-Shell (for printk() usage)","title":"1.2. Prerequisites"},{"location":"OS/OS.5.2-Thread_Communication/#20-thread-communication-in-zephyr","text":"","title":"2.0 Thread Communication in Zephyr"},{"location":"OS/OS.5.2-Thread_Communication/#21-data-passing-in-zephyr","text":"Zephyr RTOS (as of V2.7.XX) offers a few different options for ITC. To name a few, * First in first out buffers (FIFO) * Last in first out buffer (LIFO) * Stacks * Message queues, Mailboxes and Pipes Some of these are ideal for particular use cases, to determine which ITC protocol might best fit an application, refer to the Data Passing guidelines table . More information on the implementation of each primitive can be found in the api guides (links below the table ).","title":"2.1 Data Passing in Zephyr"},{"location":"OS/OS.5.2-Thread_Communication/#22-general-message-queues","text":"In this tutorial, we will focus on implementing a message queues between threads. As they can be typically be used for a wide range of applications, it is a good starting point for learning ITC in Zephyr. The api guide can be found here . What is a message queue? \" A message queue is a kernel object that implements a simple message queue, allowing threads and ISRs to asynchronously send and receive fixed-size data items .\"","title":"2.2 General Message Queues"},{"location":"OS/OS.5.2-Thread_Communication/#23-implementing-message-queues","text":"Start by making a basic Zephyr application, you may use a copy of the sample solution provided in CN.4-Shell ( shell_example ) and use this as a boilerplate. The provided solution has USB-Shell and USB-Printk enabled. Start by editing the source file. vim src/main.c The following macro allows for the definition of a message queue in Zephyr, add this to your source file. K_MSGQ_DEFINE ( my_msgq , sizeof ( struct data_packet ), 10 , 4 ); Where, a message queue named my_msgq is initialized, that queues 10 struct data_packet items, where the structure is aligned to an address that is divisible by 4 (4-byte aligned). To make this work, we must also define a struct data_packet globally (before macro usage). struct data_packet { uint16_t preamble ; char string [ 32 ]; }; In our main(), we can add some data to our struct /* MSGQ Packet */ struct data_packet packet ; packet . preamble = 0xAA ; snprintk ( packet . string , sizeof ( packet . string ), \"Colonels Recipe.exe \\n \" ); and lets put this packet on our queue, (add this to the while loop in main()) /* Send Messages to consumers */ if ( k_msgq_put ( & my_msgq , & packet , K_NO_WAIT ) != 0 ) { /* Queue is full, we could purge it, a loop can be * implemented here to keep trying after a purge. */ k_msgq_purge ( & my_msgq ); } Now, we will add another thread (alongside main), so we can test the ITC between two threads using the message queue. Note: Make sure to give this thread sufficient stack size as message queues are passed by copy . /* Define Consumer Thread */ void consumer_thread ( void ); #define STACK_SIZE 1024 #define THREAD_PRIOR 3 #define THREAD_DELAY 0 #define OPTIONS 0 K_THREAD_DEFINE ( consumer_thread_tid , STACK_SIZE , consumer_thread , NULL , NULL , NULL , THREAD_PRIOR , OPTIONS , THREAD_DELAY ); /* * Consumer thread for testing message queue */ void consumer_thread ( void ) { struct data_packet data ; while ( 1 ) { if ( k_msgq_get ( & my_msgq , & data , K_FOREVER ) == 0 ) { if ( data . preamble == 0xAA ) printk ( \"MSG Received: %s \\n \" , data . string ); memset ( & data , 0 , sizeof ( struct data_packet )); } } }","title":"2.3 Implementing Message Queues"},{"location":"OS/OS.5.2-Thread_Communication/#24-testing","text":"This application can now be built and flashed using: west build -p auto -b arduino_nano_33_ble west flash --bossac = $HOME /csse4011/BOSSA/BOSSA/bin/bossac #Check the Path is correct As per previous guides on Shell and Console implementation, attach a session to screen. sudo screen /dev/ttyACM0 [00:00:00.005,340] <inf> usb_cdc_acm: Device suspended [00:00:00.165,863] <inf> usb_cdc_acm: Device resumed [00:00:00.432,922] <inf> usb_cdc_acm: Device configured MSG Received: Colonels Recipe.exe MSG Received: Colonels Recipe.exe MSG Received: Colonels Recipe.exe MSG Received: Colonels Recipe.exe MSG Received: Colonels Recipe.exe CSSE4011:~$","title":"2.4 Testing"},{"location":"OS/OS.5.2-Thread_Communication/#25-additional-notes","text":"This tutorial is a guide for implementing basic message queues in Zephyr RTOS, it is strongly suggested that you refer to the Zephyr API guides here and here for additional information.","title":"2.5 Additional Notes"},{"location":"OS/OS.5.2-Thread_Communication/#30-sample-solution","text":"A sample solution is provided under, REPO_TOP/tute_soltions/OS-5.2_tute/ this solution implements the above functionality into a Zephyr application. Feel free to use it and modify it.","title":"3.0 Sample Solution"},{"location":"OS/about/","text":"Zephyr RTOS - Guides Summary The following set of tutorials are intended to help students get setup with Zephyr RTOS on their newly setup virtual machines (Debian based), and to get a basic application to compile. These tutorials are intended to be attempted in order , particularly the first few. Topic Brief OS.1 - Getting Started Cloning and setting up Zephyr RTOS (installing toolchains and other required packages), on Debian/Ubuntu. Building and flashing sample blinky app OS.2 - First Program Setting up and building a Zephyr application (outside Zephyr source directory) Setting up app working directories OS.2.1 - Building Tips Basics of the build system Tips to customize build system Including config files OS.2.2 - Implementing Libraries Library directory structures Adding library to app build system OS.4 - Threading Introduction to threads Thread implementation in Zephyr RTOS OS.5.1 - Thread Synchronization Introduction to thread synchronization Semphore, Mutex and Condition Variables implementation OS.5.2 - Thread Communication (ITC) Introduction to inter-thread-communication (ITC) Basic communication primitives Implementation of Zephyr message queues. Notes: The following tutorials were created with reference to Zephyr RTOS V2.7.XX . Through these guide, the reference to the environment variable (REPO_TOP) refers to the top level directory of within tutedocs.","title":"Overview"},{"location":"OS/about/#zephyr-rtos-guides","text":"","title":"Zephyr RTOS - Guides"},{"location":"OS/about/#summary","text":"The following set of tutorials are intended to help students get setup with Zephyr RTOS on their newly setup virtual machines (Debian based), and to get a basic application to compile. These tutorials are intended to be attempted in order , particularly the first few.","title":"Summary"},{"location":"OS/about/#topic-brief","text":"OS.1 - Getting Started Cloning and setting up Zephyr RTOS (installing toolchains and other required packages), on Debian/Ubuntu. Building and flashing sample blinky app OS.2 - First Program Setting up and building a Zephyr application (outside Zephyr source directory) Setting up app working directories OS.2.1 - Building Tips Basics of the build system Tips to customize build system Including config files OS.2.2 - Implementing Libraries Library directory structures Adding library to app build system OS.4 - Threading Introduction to threads Thread implementation in Zephyr RTOS OS.5.1 - Thread Synchronization Introduction to thread synchronization Semphore, Mutex and Condition Variables implementation OS.5.2 - Thread Communication (ITC) Introduction to inter-thread-communication (ITC) Basic communication primitives Implementation of Zephyr message queues.","title":"Topic Brief"},{"location":"OS/about/#notes","text":"The following tutorials were created with reference to Zephyr RTOS V2.7.XX . Through these guide, the reference to the environment variable (REPO_TOP) refers to the top level directory of within tutedocs.","title":"Notes:"}]}